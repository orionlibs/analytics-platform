{
   "activedirectorydsreceiver": {
      "attributes": {
         "bind_type": {
            "description": "The type of bind to the domain server.",
            "enum": [
               "server",
               "client"
            ],
            "name_override": "type",
            "type": "string"
         },
         "direction": {
            "description": "The direction of data flow.",
            "enum": [
               "sent",
               "received"
            ],
            "type": "string"
         },
         "network_data_type": {
            "description": "The type of network data sent.",
            "enum": [
               "compressed",
               "uncompressed"
            ],
            "name_override": "type",
            "type": "string"
         },
         "operation_type": {
            "description": "The type of operation.",
            "enum": [
               "read",
               "write",
               "search"
            ],
            "name_override": "type",
            "type": "string"
         },
         "suboperation_type": {
            "description": "The type of suboperation.",
            "enum": [
               "security_descriptor_propagations_event",
               "search"
            ],
            "name_override": "type",
            "type": "string"
         },
         "sync_result": {
            "description": "The result status of the sync request.",
            "enum": [
               "success",
               "schema_mismatch",
               "other"
            ],
            "name_override": "result",
            "type": "string"
         },
         "value_type": {
            "description": "The type of value sent.",
            "enum": [
               "distingushed_names",
               "other"
            ],
            "name_override": "type",
            "type": "string"
         }
      },
      "metrics": {
         "active_directory.ds.bind.rate": {
            "attributes": [
               "bind_type"
            ],
            "description": "The number of binds per second serviced by this domain controller.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{binds}/s"
         },
         "active_directory.ds.ldap.bind.last_successful.time": {
            "description": "The amount of time taken for the last successful LDAP bind.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "active_directory.ds.ldap.bind.rate": {
            "description": "The number of successful LDAP binds per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{binds}/s"
         },
         "active_directory.ds.ldap.client.session.count": {
            "description": "The number of connected LDAP client sessions.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "active_directory.ds.ldap.search.rate": {
            "description": "The number of LDAP searches per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{searches}/s"
         },
         "active_directory.ds.name_cache.hit_rate": {
            "description": "The percentage of directory object name component lookups that are satisfied by the Directory System Agent's name cache.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "active_directory.ds.notification.queued": {
            "description": "The number of pending update notifications that have been queued to push to clients.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{notifications}"
         },
         "active_directory.ds.operation.rate": {
            "attributes": [
               "operation_type"
            ],
            "description": "The number of operations performed per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{operations}/s"
         },
         "active_directory.ds.replication.network.io": {
            "attributes": [
               "direction",
               "network_data_type"
            ],
            "description": "The amount of network data transmitted by the Directory Replication Agent.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "active_directory.ds.replication.object.rate": {
            "attributes": [
               "direction"
            ],
            "description": "The number of objects transmitted by the Directory Replication Agent per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{objects}/s"
         },
         "active_directory.ds.replication.operation.pending": {
            "description": "The number of pending replication operations for the Directory Replication Agent.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "active_directory.ds.replication.property.rate": {
            "attributes": [
               "direction"
            ],
            "description": "The number of properties transmitted by the Directory Replication Agent per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{properties}/s"
         },
         "active_directory.ds.replication.sync.object.pending": {
            "description": "The number of objects remaining until the full sync completes for the Directory Replication Agent.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{objects}"
         },
         "active_directory.ds.replication.sync.request.count": {
            "attributes": [
               "sync_result"
            ],
            "description": "The number of sync requests made by the Directory Replication Agent.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "active_directory.ds.replication.value.rate": {
            "attributes": [
               "direction",
               "value_type"
            ],
            "description": "The number of values transmitted by the Directory Replication Agent per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{values}/s"
         },
         "active_directory.ds.security_descriptor_propagations_event.queued": {
            "description": "The number of security descriptor propagation events that are queued for processing.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{events}"
         },
         "active_directory.ds.suboperation.rate": {
            "attributes": [
               "suboperation_type"
            ],
            "description": "The rate of sub-operations performed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{suboperations}/s"
         },
         "active_directory.ds.thread.count": {
            "description": "The number of threads in use by the directory service.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "BinaryFissionGames"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "active_directory_ds"
   },
   "aerospikereceiver": {
      "attributes": {
         "connection_op": {
            "description": "Operation performed with a connection (open or close)",
            "enum": [
               "close",
               "open"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "connection_type": {
            "description": "Type of connection to an Aerospike node",
            "enum": [
               "client",
               "fabric",
               "heartbeat"
            ],
            "name_override": "type",
            "type": "string"
         },
         "index_type": {
            "description": "Type of index the operation was performed on",
            "enum": [
               "primary",
               "secondary"
            ],
            "name_override": "index",
            "type": "string"
         },
         "namespace_component": {
            "description": "Individual component of a namespace",
            "enum": [
               "data",
               "index",
               "set_index",
               "secondary_index"
            ],
            "name_override": "component",
            "type": "string"
         },
         "query_result": {
            "description": "Result of a query operation performed on a namespace",
            "enum": [
               "abort",
               "complete",
               "error",
               "timeout"
            ],
            "name_override": "result",
            "type": "string"
         },
         "query_type": {
            "description": "Type of query operation performed on a namespace",
            "enum": [
               "aggregation",
               "basic",
               "short",
               "long_basic",
               "short_basic",
               "ops_background",
               "udf_background"
            ],
            "name_override": "type",
            "type": "string"
         },
         "scan_result": {
            "description": "Result of a scan operation performed on a namespace",
            "enum": [
               "abort",
               "complete",
               "error"
            ],
            "name_override": "result",
            "type": "string"
         },
         "scan_type": {
            "description": "Type of scan operation performed on a namespace",
            "enum": [
               "aggregation",
               "basic",
               "ops_background",
               "udf_background"
            ],
            "name_override": "type",
            "type": "string"
         },
         "transaction_result": {
            "description": "Result of a transaction performed on a namespace",
            "enum": [
               "error",
               "filtered_out",
               "not_found",
               "success",
               "timeout"
            ],
            "name_override": "result",
            "type": "string"
         },
         "transaction_type": {
            "description": "Type of transaction performed on a namespace",
            "enum": [
               "delete",
               "read",
               "udf",
               "write"
            ],
            "name_override": "type",
            "type": "string"
         }
      },
      "metrics": {
         "aerospike.namespace.disk.available": {
            "description": "Minimum percentage of contiguous disk space free to the namespace across all devices",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "%"
         },
         "aerospike.namespace.geojson.region_query_cells": {
            "description": "Number of cell coverings for query region queried",
            "enabled": true,
            "extended_documentation": "Number of cell coverings for query region queried. Aerospike metric geo_region_query_cells.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{cells}"
         },
         "aerospike.namespace.geojson.region_query_false_positive": {
            "description": "Number of points outside the region.",
            "enabled": true,
            "extended_documentation": "Total query result points is geo_region_query_points + geo_region_query_falsepos. Aerospike metric geo_regio_query_falspos.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{points}"
         },
         "aerospike.namespace.geojson.region_query_points": {
            "description": "Number of points within the region.",
            "enabled": true,
            "extended_documentation": "Total query result points is geo_region_query_points + geo_region_query_falsepos. Aerospike metric geo_region_query_points.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{points}"
         },
         "aerospike.namespace.geojson.region_query_requests": {
            "description": "Number of geojson queries on the system since the uptime of the node.",
            "enabled": true,
            "extended_documentation": "Number of geojson queries on the system since the uptime of the node. Aerospike metric geo_region_query_reqs.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{queries}"
         },
         "aerospike.namespace.memory.free": {
            "description": "Percentage of the namespace's memory which is still free",
            "enabled": true,
            "extended_documentation": "Aerospike metric memory_free_pct",
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "%"
         },
         "aerospike.namespace.memory.usage": {
            "attributes": [
               "namespace_component"
            ],
            "description": "Memory currently used by each component of the namespace",
            "enabled": true,
            "extended_documentation": "Aggregate of Aerospike Metrics memory_used_data_bytes, memory_used_index_bytes, memory_used_set_index_bytes, memory_used_sindex_bytes",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "aerospike.namespace.query.count": {
            "attributes": [
               "query_type",
               "index_type",
               "query_result"
            ],
            "description": "Number of query operations performed on the namespace",
            "enabled": true,
            "extended_documentation": "Aggregate of Aerospike Metrics query_aggr_abort, query_aggr_complete, query_aggr_error, query_basic_abort, query_basic_complete, query_basic_error, query_ops_bg_abort, query_ops_bg_complete, query_ops_bg_error, query_udf_bg_abort, query_udf_bg_complete, query_udf_bg_error, pi_query_aggr_abort, pi_query_aggr_complete, pi_query_aggr_error, pi_query_long_basic_abort, pi_query_long_basic_complete, pi_query_long_basic_error, pi_query_ops_bg_abort, pi_query_ops_bg_basic_complete, pi_query_ops_bg_basic_error, pi_query_short_basic_timeout, pi_query_short_basic_complete, pi_query_short_basic_error, pi_query_udf_bg_abort, pi_query_udf_bg_complete, pi_query_udf_bg_error, si_query_aggr_abort, si_query_aggr_complete, si_query_aggr_error, si_query_long_basic_abort, si_query_long_basic_complete, si_query_long_basic_error, si_query_ops_bg_abort, si_query_ops_bg_basic_complete, si_query_ops_bg_basic_error, si_query_short_basic_timeout, si_query_short_basic_complete, si_query_short_basic_error, si_query_udf_bg_abort, si_query_udf_bg_complete, si_query_udf_bg_error",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{queries}"
         },
         "aerospike.namespace.scan.count": {
            "attributes": [
               "scan_type",
               "scan_result"
            ],
            "description": "Number of scan operations performed on the namespace",
            "enabled": true,
            "extended_documentation": "Aggregate of Aerospike Metrics scan_aggr_abort, scan_aggr_complete, scan_aggr_error, scan_basic_abort, scan_basic_complete, scan_basic_error, scan_ops_bg_abort, scan_ops_bg_complete, scan_ops_bg_error, scan_udf_bg_abort, scan_udf_bg_complete, scan_udf_bg_error",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{scans}"
         },
         "aerospike.namespace.transaction.count": {
            "attributes": [
               "transaction_type",
               "transaction_result"
            ],
            "description": "Number of transactions performed on the namespace",
            "enabled": true,
            "extended_documentation": "Aggregate of Aerospike Metrics client_delete_error, client_delete_filtered_out, client_delete_not_found, client_delete_success, client_delete_timeout, client_read_error, client_read_filtered_out, client_read_not_found, client_read_success, client_read_timeout, client_udf_error, client_udf_filtered_out, client_udf_not_found, client_udf_success, client_udf_timeout, client_write_error, client_write_filtered_out, client_write_not_found, client_write_success, client_write_timeout",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{transactions}"
         },
         "aerospike.node.connection.count": {
            "attributes": [
               "connection_type",
               "connection_op"
            ],
            "description": "Number of connections opened and closed to the node",
            "enabled": true,
            "extended_documentation": "Aggregate of Aerospike Metrics client_connections_closed, client_connections_opened, fabric_connections_closed, fabric_connections_opened, heartbeat_connections_closed, heartbeat_connections_opened",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "aerospike.node.connection.open": {
            "attributes": [
               "connection_type"
            ],
            "description": "Current number of open connections to the node",
            "enabled": true,
            "extended_documentation": "Aggregate of Aerospike Metrics client_connections, fabric_connections, heartbeat_connections",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "aerospike.node.memory.free": {
            "description": "Percentage of the node's memory which is still free",
            "enabled": true,
            "extended_documentation": "Aerospike Metric system_free_mem_pct",
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "%"
         },
         "aerospike.node.query.tracked": {
            "description": "Number of queries tracked by the system.",
            "enabled": true,
            "extended_documentation": "Number of queries which ran more than query untracked_time (default 1 sec), Aerospike metric query_tracked",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{queries}"
         }
      },
      "resource_attributes": {
         "aerospike.namespace": {
            "description": "Name of the Aerospike namespace",
            "enabled": true,
            "type": "string"
         },
         "aerospike.node.name": {
            "description": "Name of the Aerospike node collected from",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "antonblock"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "aerospike"
   },
   "aks": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/aks"
   },
   "alertmanagerexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "jpkrohling",
               "sokoide",
               "mcube8"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "development": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "alertmanager"
   },
   "alibabacloudlogserviceexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "shabicheng",
               "kongluoxing",
               "qiansheng91"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "unmaintained": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "endpoint": "http://localhost:0",
            "logstore": "otel-data",
            "project": "otel-testing"
         }
      },
      "type": "alibabacloud_logservice"
   },
   "apachereceiver": {
      "attributes": {
         "cpu_level": {
            "description": "Level of processes.",
            "enum": [
               "self",
               "children"
            ],
            "name_override": "level",
            "type": "string"
         },
         "cpu_mode": {
            "description": "Mode of processes.",
            "enum": [
               "system",
               "user"
            ],
            "name_override": "mode",
            "type": "string"
         },
         "scoreboard_state": {
            "description": "The state of a connection.",
            "enum": [
               "open",
               "waiting",
               "starting",
               "reading",
               "sending",
               "keepalive",
               "dnslookup",
               "closing",
               "logging",
               "finishing",
               "idle_cleanup",
               "unknown"
            ],
            "name_override": "state",
            "type": "string"
         },
         "workers_state": {
            "description": "The state of workers.",
            "enum": [
               "busy",
               "idle"
            ],
            "name_override": "state",
            "type": "string"
         }
      },
      "metrics": {
         "apache.cpu.load": {
            "attributes": [ ],
            "description": "Current load of the CPU.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "%"
         },
         "apache.cpu.time": {
            "attributes": [
               "cpu_level",
               "cpu_mode"
            ],
            "description": "Jiffs used by processes of given category.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "{jiff}"
         },
         "apache.current_connections": {
            "attributes": [ ],
            "description": "The number of active connections currently attached to the HTTP server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "apache.load.1": {
            "attributes": [ ],
            "description": "The average server load during the last minute.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "%"
         },
         "apache.load.15": {
            "attributes": [ ],
            "description": "The average server load during the last 15 minutes.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "%"
         },
         "apache.load.5": {
            "attributes": [ ],
            "description": "The average server load during the last 5 minutes.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "%"
         },
         "apache.request.time": {
            "attributes": [ ],
            "description": "Total time spent on handling requests.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "apache.requests": {
            "attributes": [ ],
            "description": "The number of requests serviced by the HTTP server per second.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "apache.scoreboard": {
            "attributes": [
               "scoreboard_state"
            ],
            "description": "The number of workers in each state.",
            "enabled": true,
            "extended_documentation": "The apache scoreboard is an encoded representation of the state of all the server's workers. This metric decodes the scoreboard and presents a count of workers in each state. Additional details can be found [here](https://metacpan.org/pod/Apache::Scoreboard#DESCRIPTION).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{workers}"
         },
         "apache.traffic": {
            "attributes": [ ],
            "description": "Total HTTP server traffic.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "apache.uptime": {
            "attributes": [ ],
            "description": "The amount of time that the server has been running in seconds.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         },
         "apache.workers": {
            "attributes": [
               "workers_state"
            ],
            "description": "The number of workers currently attached to the HTTP server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{workers}"
         }
      },
      "resource_attributes": {
         "apache.server.name": {
            "description": "The name of the Apache HTTP server.",
            "enabled": true,
            "type": "string"
         },
         "apache.server.port": {
            "description": "The port of the Apache HTTP server.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "apache"
   },
   "apachesparkreceiver": {
      "attributes": {
         "direction": {
            "description": "Whether the metric is in regards to input or output operations.",
            "enum": [
               "in",
               "out"
            ],
            "type": "string"
         },
         "executor_task_result": {
            "description": "The result of the executor tasks for which the metric was recorded.",
            "enum": [
               "completed",
               "failed"
            ],
            "name_override": "result",
            "type": "string"
         },
         "gc_type": {
            "description": "The type of the garbage collection performed for the metric.",
            "enum": [
               "major",
               "minor"
            ],
            "type": "string"
         },
         "job_result": {
            "description": "The result of the job stages or tasks for which the metric was recorded.",
            "enum": [
               "completed",
               "failed",
               "skipped"
            ],
            "name_override": "result",
            "type": "string"
         },
         "location": {
            "description": "The location of the memory for which the metric was recorded..",
            "enum": [
               "on_heap",
               "off_heap"
            ],
            "type": "string"
         },
         "pool_memory_type": {
            "description": "The type of pool memory for which the metric was recorded.",
            "enum": [
               "direct",
               "mapped"
            ],
            "name_override": "type",
            "type": "string"
         },
         "scheduler_status": {
            "description": "The status of the DAGScheduler stages for which the metric was recorded.",
            "enum": [
               "waiting",
               "running"
            ],
            "name_override": "status",
            "type": "string"
         },
         "source": {
            "description": "The source from which data was fetched for the metric.",
            "enum": [
               "local",
               "remote"
            ],
            "type": "string"
         },
         "stage_active": {
            "description": "Whether the stage for which the metric was recorded is active.",
            "name_override": "active",
            "type": "bool"
         },
         "stage_complete": {
            "description": "Whether the stage for which the metric was recorded is complete.",
            "name_override": "complete",
            "type": "bool"
         },
         "stage_failed": {
            "description": "Whether the stage for which the metric was recorded is failed.",
            "name_override": "failed",
            "type": "bool"
         },
         "stage_pending": {
            "description": "Whether the stage for which the metric was recorded is pending.",
            "name_override": "pending",
            "type": "bool"
         },
         "stage_task_result": {
            "description": "The result of the stage tasks for which the metric was recorded.",
            "enum": [
               "completed",
               "failed",
               "killed"
            ],
            "name_override": "result",
            "type": "string"
         },
         "state": {
            "description": "The state of the memory for which the metric was recorded.",
            "enum": [
               "used",
               "free"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "spark.driver.block_manager.disk.usage": {
            "attributes": [ ],
            "description": "Disk space used by the BlockManager.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "mb"
         },
         "spark.driver.block_manager.memory.usage": {
            "attributes": [
               "location",
               "state"
            ],
            "description": "Memory usage for the driver's BlockManager.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "mb"
         },
         "spark.driver.code_generator.compilation.average_time": {
            "attributes": [ ],
            "description": "Average time spent during CodeGenerator source code compilation operations.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "ms"
         },
         "spark.driver.code_generator.compilation.count": {
            "attributes": [ ],
            "description": "Number of source code compilation operations performed by the CodeGenerator.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ compilation }"
         },
         "spark.driver.code_generator.generated_class.average_size": {
            "attributes": [ ],
            "description": "Average class size of the classes generated by the CodeGenerator.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "bytes"
         },
         "spark.driver.code_generator.generated_class.count": {
            "attributes": [ ],
            "description": "Number of classes generated by the CodeGenerator.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ class }"
         },
         "spark.driver.code_generator.generated_method.average_size": {
            "attributes": [ ],
            "description": "Average method size of the classes generated by the CodeGenerator.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "bytes"
         },
         "spark.driver.code_generator.generated_method.count": {
            "attributes": [ ],
            "description": "Number of methods generated by the CodeGenerator.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ method }"
         },
         "spark.driver.code_generator.source_code.average_size": {
            "attributes": [ ],
            "description": "Average size of the source code generated by a CodeGenerator code generation operation.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "bytes"
         },
         "spark.driver.code_generator.source_code.operations": {
            "attributes": [ ],
            "description": "Number of source code generation operations performed by the CodeGenerator.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ operation }"
         },
         "spark.driver.dag_scheduler.job.active": {
            "attributes": [ ],
            "description": "Number of active jobs currently being processed by the DAGScheduler.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ job }"
         },
         "spark.driver.dag_scheduler.job.count": {
            "attributes": [ ],
            "description": "Number of jobs that have been submitted to the DAGScheduler.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ job }"
         },
         "spark.driver.dag_scheduler.stage.count": {
            "attributes": [
               "scheduler_status"
            ],
            "description": "Number of stages the DAGScheduler is either running or needs to run.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ stage }"
         },
         "spark.driver.dag_scheduler.stage.failed": {
            "attributes": [ ],
            "description": "Number of failed stages run by the DAGScheduler.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ stage }"
         },
         "spark.driver.executor.gc.operations": {
            "attributes": [
               "gc_type"
            ],
            "description": "Number of garbage collection operations performed by the driver.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ gc_operation }"
         },
         "spark.driver.executor.gc.time": {
            "attributes": [
               "gc_type"
            ],
            "description": "Total elapsed time during garbage collection operations performed by the driver.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "spark.driver.executor.memory.execution": {
            "attributes": [
               "location"
            ],
            "description": "Amount of execution memory currently used by the driver.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.driver.executor.memory.jvm": {
            "attributes": [
               "location"
            ],
            "description": "Amount of memory used by the driver's JVM.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.driver.executor.memory.pool": {
            "attributes": [
               "pool_memory_type"
            ],
            "description": "Amount of pool memory currently used by the driver.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.driver.executor.memory.storage": {
            "attributes": [
               "location"
            ],
            "description": "Amount of storage memory currently used by the driver.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.driver.hive_external_catalog.file_cache_hits": {
            "attributes": [ ],
            "description": "Number of file cache hits on the HiveExternalCatalog.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ hit }"
         },
         "spark.driver.hive_external_catalog.files_discovered": {
            "attributes": [ ],
            "description": "Number of files discovered while listing the partitions of a table in the Hive metastore",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ file }"
         },
         "spark.driver.hive_external_catalog.hive_client_calls": {
            "attributes": [ ],
            "description": "Number of calls to the underlying Hive Metastore client made by the Spark application.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ call }"
         },
         "spark.driver.hive_external_catalog.parallel_listing_jobs": {
            "attributes": [ ],
            "description": "Number of parallel listing jobs initiated by the HiveExternalCatalog when listing partitions of a table.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ listing_job }"
         },
         "spark.driver.hive_external_catalog.partitions_fetched": {
            "attributes": [ ],
            "description": "Table partitions fetched by the HiveExternalCatalog.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ partition }"
         },
         "spark.driver.jvm_cpu_time": {
            "attributes": [ ],
            "description": "Current CPU time taken by the Spark driver.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "spark.driver.live_listener_bus.dropped": {
            "attributes": [ ],
            "description": "Number of events that have been dropped by the LiveListenerBus.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ event }"
         },
         "spark.driver.live_listener_bus.posted": {
            "attributes": [ ],
            "description": "Number of events that have been posted on the LiveListenerBus.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ event }"
         },
         "spark.driver.live_listener_bus.processing_time.average": {
            "attributes": [ ],
            "description": "Average time taken for the LiveListenerBus to process an event posted to it.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "ms"
         },
         "spark.driver.live_listener_bus.queue_size": {
            "attributes": [ ],
            "description": "Number of events currently waiting to be processed by the LiveListenerBus.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ event }"
         },
         "spark.executor.disk.usage": {
            "attributes": [ ],
            "description": "Disk space used by this executor for RDD storage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.executor.gc_time": {
            "attributes": [ ],
            "description": "Elapsed time the JVM spent in garbage collection in this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "spark.executor.input_size": {
            "attributes": [ ],
            "description": "Amount of data input for this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.executor.memory.usage": {
            "attributes": [ ],
            "description": "Storage memory used by this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.executor.shuffle.io.size": {
            "attributes": [
               "direction"
            ],
            "description": "Amount of data written and read during shuffle operations for this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.executor.storage_memory.usage": {
            "attributes": [
               "location",
               "state"
            ],
            "description": "The executor's storage memory usage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.executor.task.active": {
            "attributes": [ ],
            "description": "Number of tasks currently running in this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.executor.task.limit": {
            "attributes": [ ],
            "description": "Maximum number of tasks that can run concurrently in this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.executor.task.result": {
            "attributes": [
               "executor_task_result"
            ],
            "description": "Number of tasks with a specific result in this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.executor.time": {
            "attributes": [ ],
            "description": "Elapsed time the JVM spent executing tasks in this executor.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "spark.job.stage.active": {
            "attributes": [ ],
            "description": "Number of active stages in this job.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ stage }"
         },
         "spark.job.stage.result": {
            "attributes": [
               "job_result"
            ],
            "description": "Number of stages with a specific result in this job.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ stage }"
         },
         "spark.job.task.active": {
            "attributes": [ ],
            "description": "Number of active tasks in this job.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.job.task.result": {
            "attributes": [
               "job_result"
            ],
            "description": "Number of tasks with a specific result in this job.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.stage.disk.spilled": {
            "attributes": [ ],
            "description": "The amount of disk space used for storing portions of overly large data chunks that couldn't fit in memory in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.executor.cpu_time": {
            "attributes": [ ],
            "description": "CPU time spent by the executor in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "spark.stage.executor.run_time": {
            "attributes": [ ],
            "description": "Amount of time spent by the executor in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "spark.stage.io.records": {
            "attributes": [
               "direction"
            ],
            "description": "Number of records written and read in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ record }"
         },
         "spark.stage.io.size": {
            "attributes": [
               "direction"
            ],
            "description": "Amount of data written and read at this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.jvm_gc_time": {
            "attributes": [ ],
            "description": "The amount of time the JVM spent on garbage collection in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "spark.stage.memory.peak": {
            "attributes": [ ],
            "description": "Peak memory used by internal data structures created during shuffles, aggregations and joins in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.memory.spilled": {
            "attributes": [ ],
            "description": "The amount of memory moved to disk due to size constraints (spilled) in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.shuffle.blocks_fetched": {
            "attributes": [
               "source"
            ],
            "description": "Number of blocks fetched in shuffle operations in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ block }"
         },
         "spark.stage.shuffle.fetch_wait_time": {
            "attributes": [ ],
            "description": "Time spent in this stage waiting for remote shuffle blocks.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "spark.stage.shuffle.io.disk": {
            "attributes": [ ],
            "description": "Amount of data read to disk in shuffle operations (sometimes required for large blocks, as opposed to the default behavior of reading into memory).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.shuffle.io.read.size": {
            "attributes": [
               "source"
            ],
            "description": "Amount of data read in shuffle operations in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.shuffle.io.records": {
            "attributes": [
               "direction"
            ],
            "description": "Number of records written or read in shuffle operations in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ record }"
         },
         "spark.stage.shuffle.io.write.size": {
            "attributes": [ ],
            "description": "Amount of data written in shuffle operations in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         },
         "spark.stage.shuffle.write_time": {
            "attributes": [ ],
            "description": "Time spent blocking on writes to disk or buffer cache in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "spark.stage.status": {
            "attributes": [
               "stage_active",
               "stage_complete",
               "stage_pending",
               "stage_failed"
            ],
            "description": "A one-hot encoding representing the status of this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ status }"
         },
         "spark.stage.task.active": {
            "attributes": [ ],
            "description": "Number of active tasks in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.stage.task.result": {
            "attributes": [
               "stage_task_result"
            ],
            "description": "Number of tasks with a specific result in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{ task }"
         },
         "spark.stage.task.result_size": {
            "attributes": [ ],
            "description": "The amount of data transmitted back to the driver by all the tasks in this stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "bytes"
         }
      },
      "resource_attributes": {
         "spark.application.id": {
            "description": "The ID of the application for which the metric was recorded.",
            "enabled": true,
            "type": "string"
         },
         "spark.application.name": {
            "description": "The name of the application for which the metric was recorded.",
            "enabled": true,
            "type": "string"
         },
         "spark.executor.id": {
            "description": "The ID of the executor for which the metric was recorded.",
            "enabled": true,
            "type": "string"
         },
         "spark.job.id": {
            "description": "The ID of the job for which the metric was recorded.",
            "enabled": true,
            "type": "int"
         },
         "spark.stage.attempt.id": {
            "description": "The ID of the stage attempt for which the metric was recorded.",
            "type": "int"
         },
         "spark.stage.id": {
            "description": "The ID of the application stage for which the metric was recorded.",
            "enabled": true,
            "type": "int"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "Caleb-Hurshman",
               "mrsillydog"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "apachespark"
   },
   "attributesprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "boostchicken"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "redhat",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         },
         "warnings": [
            "Identity Conflict"
         ]
      },
      "tests": {
         "config": {
            "actions": [
               {
                  "action": "insert",
                  "key": "attribute1",
                  "value": 123
               }
            ]
         }
      },
      "type": "attributes"
   },
   "awscloudwatchlogsexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "boostchicken",
               "bryan-aguilar",
               "rapphil"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "type": "awscloudwatchlogs"
   },
   "awscloudwatchmetricsreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "jpkrohling"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "awscloudwatchmetrics"
   },
   "awscloudwatchreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "schmikei"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "awscloudwatch"
   },
   "awscontainerinsightreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "pxaws"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         },
         "warnings": [
            "Other"
         ]
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "awscontainerinsightreceiver"
   },
   "awsecscontainermetricsreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "Aneurysm9"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "awsecscontainermetrics"
   },
   "awsemfexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "shaochengwang",
               "mxiamxia",
               "bryan-aguilar"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "awsemf"
   },
   "awsfirehosereceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "Aneurysm9"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "awsfirehose"
   },
   "awskinesisexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "awskinesis"
   },
   "awss3exporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "atoulme",
               "pdelewski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo",
            "splunk"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null,
         "expect_consumer_error": true
      },
      "type": "awss3"
   },
   "awsxrayexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "wangzlei",
               "srprash"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "type": "awsxray"
   },
   "awsxrayreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "wangzlei",
               "srprash"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "type": "awsxray"
   },
   "azure": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "azure.resourcegroup.name": {
            "description": "The azure.resourcegroup.name",
            "enabled": true,
            "type": "string"
         },
         "azure.vm.name": {
            "description": "The azure.vm.name",
            "enabled": true,
            "type": "string"
         },
         "azure.vm.scaleset.name": {
            "description": "The azure.vm.scaleset.name",
            "enabled": true,
            "type": "string"
         },
         "azure.vm.size": {
            "description": "The azure.vm.size",
            "enabled": true,
            "type": "string"
         },
         "cloud.account.id": {
            "description": "The cloud.account.id",
            "enabled": true,
            "type": "string"
         },
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud.region",
            "enabled": true,
            "type": "string"
         },
         "host.id": {
            "description": "The host.id",
            "enabled": true,
            "type": "string"
         },
         "host.name": {
            "description": "The hostname",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "mx-psi"
            ]
         }
      },
      "type": "resourcedetectionprocessor/azure"
   },
   "azureblobreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "eedorenko",
               "mx-psi"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "development": [
               "logs",
               "traces"
            ]
         }
      },
      "tests": {
         "config": {
            "connection_string": "DefaultEndpointsProtocol=https;AccountName=accountName;AccountKey=+idLkHYcL0MUWIKYHm2j4Q==;EndpointSuffix=core.windows.net"
         },
         "skip_lifecycle": true
      },
      "type": "azureblob"
   },
   "azuredataexplorerexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "asaharn",
               "ag-ramachandran"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "azuredataexplorer"
   },
   "azureeventhubreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme",
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "azureeventhub"
   },
   "azuremonitorexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "pcwiese"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "azuremonitor"
   },
   "azuremonitorreceiver": {
      "resource_attributes": {
         "azuremonitor.subscription_id": {
            "description": "Azure subscription ID",
            "type": "string"
         },
         "azuremonitor.tenant_id": {
            "description": "Azure tenant ID",
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "altuner",
               "codeboten"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": {
            "client_secret": "secret",
            "tenant_id": "id"
         }
      },
      "type": "azuremonitor"
   },
   "batchprocessor": {
      "status": {
         "class": "processor",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "batch"
   },
   "bigipreceiver": {
      "attributes": {
         "active.status": {
            "description": "The active status.",
            "enum": [
               "active",
               "inactive"
            ],
            "name_override": "status",
            "type": "string"
         },
         "availability.status": {
            "description": "The availability status.",
            "enum": [
               "offline",
               "unknown",
               "available"
            ],
            "name_override": "status",
            "type": "string"
         },
         "direction": {
            "description": "The direction of data.",
            "enum": [
               "sent",
               "received"
            ],
            "type": "string"
         },
         "enabled.status": {
            "description": "The enabled status.",
            "enum": [
               "disabled",
               "enabled"
            ],
            "name_override": "status",
            "type": "string"
         }
      },
      "metrics": {
         "bigip.node.availability": {
            "attributes": [
               "availability.status"
            ],
            "description": "Availability of the node.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.node.connection.count": {
            "description": "Current number of connections to the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "bigip.node.data.transmitted": {
            "attributes": [
               "direction"
            ],
            "description": "Amount of data transmitted to and from the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "bigip.node.enabled": {
            "attributes": [
               "enabled.status"
            ],
            "description": "Enabled state of of the node.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.node.packet.count": {
            "attributes": [
               "direction"
            ],
            "description": "Number of packets transmitted to and from the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "bigip.node.request.count": {
            "description": "Number of requests to the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "bigip.node.session.count": {
            "description": "Current number of sessions for the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "bigip.pool.availability": {
            "attributes": [
               "availability.status"
            ],
            "description": "Availability of the pool.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.pool.connection.count": {
            "description": "Current number of connections to the pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "bigip.pool.data.transmitted": {
            "attributes": [
               "direction"
            ],
            "description": "Amount of data transmitted to and from the pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "bigip.pool.enabled": {
            "attributes": [
               "enabled.status"
            ],
            "description": "Enabled state of of the pool.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.pool.member.count": {
            "attributes": [
               "active.status"
            ],
            "description": "Total number of pool members.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{members}"
         },
         "bigip.pool.packet.count": {
            "attributes": [
               "direction"
            ],
            "description": "Number of packets transmitted to and from the pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "bigip.pool.request.count": {
            "description": "Number of requests to the pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "bigip.pool_member.availability": {
            "attributes": [
               "availability.status"
            ],
            "description": "Availability of the pool member.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.pool_member.connection.count": {
            "description": "Current number of connections to the pool member.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "bigip.pool_member.data.transmitted": {
            "attributes": [
               "direction"
            ],
            "description": "Amount of data transmitted to and from the pool member.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "bigip.pool_member.enabled": {
            "attributes": [
               "enabled.status"
            ],
            "description": "Enabled state of of the pool member.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.pool_member.packet.count": {
            "attributes": [
               "direction"
            ],
            "description": "Number of packets transmitted to and from the pool member.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "bigip.pool_member.request.count": {
            "description": "Number of requests to the pool member.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "bigip.pool_member.session.count": {
            "description": "Current number of sessions for the pool member.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "bigip.virtual_server.availability": {
            "attributes": [
               "availability.status"
            ],
            "description": "Availability of the virtual server.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.virtual_server.connection.count": {
            "description": "Current number of connections to the virtual server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "bigip.virtual_server.data.transmitted": {
            "attributes": [
               "direction"
            ],
            "description": "Amount of data transmitted to and from the virtual server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "bigip.virtual_server.enabled": {
            "attributes": [
               "enabled.status"
            ],
            "description": "Enabled state of of the virtual server.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "bigip.virtual_server.packet.count": {
            "attributes": [
               "direction"
            ],
            "description": "Number of packets transmitted to and from the virtual server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "bigip.virtual_server.request.count": {
            "description": "Number of requests to the virtual server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         }
      },
      "resource_attributes": {
         "bigip.node.ip_address": {
            "description": "The IP Address of the Big-IP Node.",
            "enabled": true,
            "type": "string"
         },
         "bigip.node.name": {
            "description": "The name of the Big-IP Node.",
            "enabled": true,
            "type": "string"
         },
         "bigip.pool.name": {
            "description": "The name of the Big-IP Pool.",
            "enabled": true,
            "type": "string"
         },
         "bigip.pool_member.ip_address": {
            "description": "The IP Address of the Big-IP Pool Member.",
            "enabled": true,
            "type": "string"
         },
         "bigip.pool_member.name": {
            "description": "The name of the Big-IP Pool Member.",
            "enabled": true,
            "type": "string"
         },
         "bigip.virtual_server.destination": {
            "description": "The destination for the Big-IP Virtual Server.",
            "enabled": true,
            "type": "string"
         },
         "bigip.virtual_server.name": {
            "description": "The name of the Big-IP Virtual Server.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "StefanKurek"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "bigip"
   },
   "carbonexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "aboguszewski-sumo"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "carbon"
   },
   "carbonreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "aboguszewski-sumo"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "carbon"
   },
   "cassandraexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "atoulme",
               "emreyalvac"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "traces",
               "logs"
            ]
         }
      },
      "type": "cassandra"
   },
   "chronyreceiver": [
      {
         "attributes": {
            "leap.status": {
               "description": "how the chrony is handling leap seconds",
               "enum": [
                  "normal",
                  "insert_second",
                  "delete_second",
                  "unsynchronised"
               ],
               "type": "string"
            }
         },
         "metrics": {
            "ntp.frequency.offset": {
               "attributes": [
                  "leap.status"
               ],
               "description": "The frequency is the rate by which the system s clock would be wrong if chronyd was not correcting it.",
               "enabled": false,
               "extended_documentation": "It is expressed in ppm (parts per million). For example, a value of 1 ppm would mean that when the systems clock thinks it has advanced 1 second, it has actually advanced by 1.000001 seconds relative to true time.",
               "gauge": {
                  "value_type": "double"
               },
               "unit": "ppm"
            },
            "ntp.skew": {
               "description": "This is the estimated error bound on the frequency.",
               "enabled": true,
               "gauge": {
                  "value_type": "double"
               },
               "unit": "ppm"
            },
            "ntp.stratum": {
               "description": "The number of hops away from the reference system keeping the reference time",
               "enabled": false,
               "extended_documentation": "To read further, refer to https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-configuring_ntp_using_the_chrony_suite#sect-Checking_chrony_tracking",
               "gauge": {
                  "value_type": "int"
               },
               "unit": "{count}"
            },
            "ntp.time.correction": {
               "attributes": [
                  "leap.status"
               ],
               "description": "The number of seconds difference between the system's clock and the reference clock",
               "enabled": true,
               "gauge": {
                  "value_type": "double"
               },
               "unit": "seconds"
            },
            "ntp.time.last_offset": {
               "attributes": [
                  "leap.status"
               ],
               "description": "The estimated local offset on the last clock update",
               "enabled": true,
               "gauge": {
                  "value_type": "double"
               },
               "unit": "seconds"
            },
            "ntp.time.rms_offset": {
               "attributes": [
                  "leap.status"
               ],
               "description": "the long term average of the offset value",
               "enabled": false,
               "gauge": {
                  "value_type": "double"
               },
               "unit": "seconds"
            },
            "ntp.time.root_delay": {
               "attributes": [
                  "leap.status"
               ],
               "description": "This is the total of the network path delays to the stratum-1 system from which the system is ultimately synchronised.",
               "enabled": false,
               "gauge": {
                  "value_type": "double"
               },
               "unit": "seconds"
            }
         },
         "status": {
            "class": "receiver",
            "codeowners": {
               "active": [
                  "MovieStoreGuy",
                  "jamesmoessis"
               ]
            },
            "distributions": [
               "contrib"
            ],
            "stability": {
               "alpha": [
                  "metrics"
               ]
            }
         },
         "type": "chrony"
      }
   ],
   "clickhouseexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "hanjm",
               "dmitryax",
               "Frapschen"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "clickhouse"
   },
   "cloudflarereceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dehaansa",
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "cloudflare"
   },
   "cloudfoundryreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "pellared",
               "crobert-1"
            ],
            "emeritus": [
               "agoallikmaa"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "cloudfoundry"
   },
   "collectdreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "collectd"
   },
   "consul": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "azure.resourcegroup.name": {
            "description": "The azure.resourcegroup.name",
            "enabled": true,
            "type": "string"
         },
         "azure.vm.name": {
            "description": "The azure.vm.name",
            "enabled": true,
            "type": "string"
         },
         "azure.vm.scaleset.name": {
            "description": "The azure.vm.scaleset.name",
            "enabled": true,
            "type": "string"
         },
         "azure.vm.size": {
            "description": "The azure.vm.size",
            "enabled": true,
            "type": "string"
         },
         "cloud.account.id": {
            "description": "The cloud.account.id",
            "enabled": true,
            "type": "string"
         },
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud.region",
            "enabled": true,
            "type": "string"
         },
         "host.id": {
            "description": "The host.id",
            "enabled": true,
            "type": "string"
         },
         "host.name": {
            "description": "The hostname",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/consul"
   },
   "coralogixexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "povilasv",
               "matej-g"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "coralogix"
   },
   "couchdbreceiver": {
      "attributes": {
         "http.method": {
            "description": "An HTTP request method.",
            "enum": [
               "COPY",
               "DELETE",
               "GET",
               "HEAD",
               "OPTIONS",
               "POST",
               "PUT"
            ],
            "type": "string"
         },
         "http.status_code": {
            "description": "An HTTP status code.",
            "type": "string"
         },
         "operation": {
            "description": "The operation type.",
            "enum": [
               "writes",
               "reads"
            ],
            "type": "string"
         },
         "view": {
            "description": "The view type.",
            "enum": [
               "temporary_view_reads",
               "view_reads"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "couchdb.average_request_time": {
            "description": "The average duration of a served request.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "ms"
         },
         "couchdb.database.open": {
            "description": "The number of open databases.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{databases}"
         },
         "couchdb.database.operations": {
            "attributes": [
               "operation"
            ],
            "description": "The number of database operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "couchdb.file_descriptor.open": {
            "description": "The number of open file descriptors.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{files}"
         },
         "couchdb.httpd.bulk_requests": {
            "description": "The number of bulk requests.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "couchdb.httpd.requests": {
            "attributes": [
               "http.method"
            ],
            "description": "The number of HTTP requests by method.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "couchdb.httpd.responses": {
            "attributes": [
               "http.status_code"
            ],
            "description": "The number of each HTTP status code.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{responses}"
         },
         "couchdb.httpd.views": {
            "attributes": [
               "view"
            ],
            "description": "The number of views read.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{views}"
         }
      },
      "resource_attributes": {
         "couchdb.node.name": {
            "description": "The name of the node.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "couchdb"
   },
   "cpuscraper": {
      "attributes": {
         "cpu": {
            "description": "Logical CPU number starting at 0.",
            "type": "string"
         },
         "state": {
            "description": "Breakdown of CPU usage by type.",
            "enum": [
               "idle",
               "interrupt",
               "nice",
               "softirq",
               "steal",
               "system",
               "user",
               "wait"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "system.cpu.frequency": {
            "attributes": [
               "cpu"
            ],
            "description": "Current frequency of the CPU core in Hz.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "Hz"
         },
         "system.cpu.logical.count": {
            "description": "Number of available logical CPUs.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{cpu}"
         },
         "system.cpu.physical.count": {
            "description": "Number of available physical CPUs.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{cpu}"
         },
         "system.cpu.time": {
            "attributes": [
               "cpu",
               "state"
            ],
            "description": "Total seconds each logical CPU spent on each mode.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "system.cpu.utilization": {
            "attributes": [
               "cpu",
               "state"
            ],
            "description": "Difference in system.cpu.time since the last measurement per logical CPU, divided by the elapsed time (value in interval [0,1]).",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/cpu"
   },
   "cumulativetodeltaprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "TylerHelmuth"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo",
            "aws"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         },
         "warnings": [
            "Statefulness"
         ]
      },
      "tests": {
         "config": null
      },
      "type": "cumulativetodelta"
   },
   "datadogexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "mx-psi",
               "dineshg13",
               "liustanley",
               "songy23",
               "mackjmr"
            ],
            "emeritus": [
               "gbbr"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq"
         ],
         "stability": {
            "alpha": [
               "logs"
            ],
            "beta": [
               "traces",
               "metrics"
            ]
         }
      },
      "type": "datadog"
   },
   "datadogprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "mx-psi",
               "dineshg13"
            ],
            "emeritus": [
               "gbbr"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "deprecated": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "datadog"
   },
   "datadogreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "boostchicken",
               "gouthamve",
               "jpkrohling",
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "traces"
            ]
         }
      },
      "type": "datadog"
   },
   "datasetexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "atoulme",
               "martin-majlis-s1",
               "zdaratom",
               "tomaz-s1"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "logs",
               "traces"
            ]
         }
      },
      "type": "dataset"
   },
   "debugexporter": {
      "status": {
         "class": "exporter",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "development": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "debug"
   },
   "deltatorateprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "Aneurysm9"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo",
            "aws"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "deltatorate"
   },
   "diskscraper": {
      "attributes": {
         "device": {
            "description": "Name of the disk.",
            "type": "string"
         },
         "direction": {
            "description": "Direction of flow of bytes/operations (read or write).",
            "enum": [
               "read",
               "write"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "system.disk.io": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "Disk bytes transferred.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.disk.io_time": {
            "attributes": [
               "device"
            ],
            "description": "Time disk spent activated. On Windows, this is calculated as the inverse of disk idle time.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "system.disk.merged": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "The number of disk reads/writes merged into single physical disk access operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "system.disk.operation_time": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "Time spent in disk operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "system.disk.operations": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "Disk operations count.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "system.disk.pending_operations": {
            "attributes": [
               "device"
            ],
            "description": "The queue size of pending I/O operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "system.disk.weighted_io_time": {
            "attributes": [
               "device"
            ],
            "description": "Time disk spent activated multiplied by the queue length.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/disk"
   },
   "docker": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "host.name": {
            "description": "The host.name",
            "enabled": true,
            "type": "string"
         },
         "os.type": {
            "description": "The os.type",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/docker"
   },
   "dockerstatsreceiver": {
      "attributes": {
         "core": {
            "description": "The CPU core number when utilising per-CPU metrics.",
            "type": "string"
         },
         "device_major": {
            "description": "Device major number for block IO operations.",
            "type": "string"
         },
         "device_minor": {
            "description": "Device minor number for block IO operations.",
            "type": "string"
         },
         "interface": {
            "description": "Network interface.",
            "type": "string"
         },
         "operation": {
            "description": "Type of BlockIO operation.",
            "type": "string"
         }
      },
      "metrics": {
         "container.blockio.io_merged_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Number of bios/requests merged into requests belonging to this cgroup and its descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.blockio.io_queued_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Number of requests queued up for this cgroup and its descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.blockio.io_service_bytes_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Number of bytes transferred to/from the disk by the group and descendant groups.",
            "enabled": true,
            "extended_documentation": "More docs for [cgroups v1](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt) and [cgroups v2](https://www.kernel.org/doc/Documentation/cgroup-v2.txt)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.blockio.io_service_time_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Total amount of time in nanoseconds between request dispatch and request completion for the IOs done by this cgroup and descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.blockio.io_serviced_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Number of IOs (bio) issued to the disk by the group and descendant groups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.blockio.io_time_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Disk time allocated to cgroup (and descendant cgroups) per device in milliseconds (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "container.blockio.io_wait_time_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Total amount of time the IOs for this cgroup (and descendant cgroups) spent waiting in the scheduler queues for service (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.blockio.sectors_recursive": {
            "attributes": [
               "device_major",
               "device_minor",
               "operation"
            ],
            "description": "Number of sectors transferred to/from disk by the group and descendant groups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{sectors}"
         },
         "container.cpu.limit": {
            "description": "CPU limit set for the container.",
            "enabled": false,
            "extended_documentation": "This metric is only reported if the container has limits set with -cpus, -cpuset-cpus or -cpu-quota.",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{cpus}"
         },
         "container.cpu.shares": {
            "description": "CPU shares set for the container.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "1"
         },
         "container.cpu.throttling_data.periods": {
            "description": "Number of periods with throttling active.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{periods}"
         },
         "container.cpu.throttling_data.throttled_periods": {
            "description": "Number of periods when the container hits its throttling limit.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{periods}"
         },
         "container.cpu.throttling_data.throttled_time": {
            "description": "Aggregate time the container was throttled.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.cpu.usage.kernelmode": {
            "description": "Time spent by tasks of the cgroup in kernel mode (Linux).  Time spent by all container processes in kernel mode (Windows).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.cpu.usage.percpu": {
            "attributes": [
               "core"
            ],
            "description": "Per-core CPU usage by the container (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.cpu.usage.system": {
            "description": "System CPU usage, as reported by docker.",
            "enabled": false,
            "extended_documentation": "Note this is the usage for the system, not the container.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.cpu.usage.total": {
            "description": "Total CPU time consumed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.cpu.usage.usermode": {
            "description": "Time spent by tasks of the cgroup in user mode (Linux).  Time spent by all container processes in user mode (Windows).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "container.cpu.utilization": {
            "description": "Percent of CPU used by the container.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "1"
         },
         "container.memory.active_anon": {
            "description": "The amount of anonymous memory that has been identified as active by the kernel.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.active_file": {
            "description": "Cache memory that has been identified as active by the kernel.",
            "enabled": false,
            "extended_documentation": "[More docs](https://docs.docker.com/config/containers/runmetrics/)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.anon": {
            "description": "Amount of memory used in anonymous mappings such as brk(), sbrk(), and mmap(MAP_ANONYMOUS) (Only available with cgroups v2).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v2.txt)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.cache": {
            "description": "The amount of memory used by the processes of this control group that can be associated precisely with a block on a block device (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.dirty": {
            "description": "Bytes that are waiting to get written back to the disk, from this cgroup (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.file": {
            "description": "Amount of memory used to cache filesystem data, including tmpfs and shared memory (Only available with cgroups v2).",
            "enabled": true,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v2.txt)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.hierarchical_memory_limit": {
            "description": "The maximum amount of physical memory that can be used by the processes of this control group (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.hierarchical_memsw_limit": {
            "description": "The maximum amount of RAM + swap that can be used by the processes of this control group (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.inactive_anon": {
            "description": "The amount of anonymous memory that has been identified as inactive by the kernel.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.inactive_file": {
            "description": "Cache memory that has been identified as inactive by the kernel.",
            "enabled": false,
            "extended_documentation": "[More docs](https://docs.docker.com/config/containers/runmetrics/)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.mapped_file": {
            "description": "Indicates the amount of memory mapped by the processes in the control group (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.percent": {
            "description": "Percentage of memory used.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "container.memory.pgfault": {
            "description": "Indicate the number of times that a process of the cgroup triggered a page fault.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{faults}"
         },
         "container.memory.pgmajfault": {
            "description": "Indicate the number of times that a process of the cgroup triggered a major fault.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{faults}"
         },
         "container.memory.pgpgin": {
            "description": "Number of pages read from disk by the cgroup (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.memory.pgpgout": {
            "description": "Number of pages written to disk by the cgroup (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.memory.rss": {
            "description": "The amount of memory that doesnt correspond to anything on disk: stacks, heaps, and anonymous memory maps (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.rss_huge": {
            "description": "Number of bytes of anonymous transparent hugepages in this cgroup (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_active_anon": {
            "description": "The amount of anonymous memory that has been identified as active by the kernel. Includes descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_active_file": {
            "description": "Cache memory that has been identified as active by the kernel. Includes descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://docs.docker.com/config/containers/runmetrics/).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_cache": {
            "description": "Total amount of memory used by the processes of this cgroup (and descendants) that can be associated with a block on a block device. Also accounts for memory used by tmpfs (Only available with cgroups v1).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_dirty": {
            "description": "Bytes that are waiting to get written back to the disk, from this cgroup and descendants (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_inactive_anon": {
            "description": "The amount of anonymous memory that has been identified as inactive by the kernel. Includes descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_inactive_file": {
            "description": "Cache memory that has been identified as inactive by the kernel. Includes descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "extended_documentation": "[More docs](https://docs.docker.com/config/containers/runmetrics/).",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_mapped_file": {
            "description": "Indicates the amount of memory mapped by the processes in the control group and descendant groups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_pgfault": {
            "description": "Indicate the number of times that a process of the cgroup (or descendant cgroups) triggered a page fault (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{faults}"
         },
         "container.memory.total_pgmajfault": {
            "description": "Indicate the number of times that a process of the cgroup (or descendant cgroups) triggered a major fault (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{faults}"
         },
         "container.memory.total_pgpgin": {
            "description": "Number of pages read from disk by the cgroup and descendant groups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.memory.total_pgpgout": {
            "description": "Number of pages written to disk by the cgroup and descendant groups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "container.memory.total_rss": {
            "description": "The amount of memory that doesnt correspond to anything on disk: stacks, heaps, and anonymous memory maps. Includes descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_rss_huge": {
            "description": "Number of bytes of anonymous transparent hugepages in this cgroup and descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_unevictable": {
            "description": "The amount of memory that cannot be reclaimed. Includes descendant cgroups (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.total_writeback": {
            "description": "Number of bytes of file/anon cache that are queued for syncing to disk in this cgroup and descendants (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.unevictable": {
            "description": "The amount of memory that cannot be reclaimed.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.usage.limit": {
            "description": "Memory limit of the container.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.usage.max": {
            "description": "Maximum memory usage.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.usage.total": {
            "description": "Memory usage of the container. This excludes the cache.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.writeback": {
            "description": "Number of bytes of file/anon cache that are queued for syncing to disk in this cgroup (Only available with cgroups v1).",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.network.io.usage.rx_bytes": {
            "attributes": [
               "interface"
            ],
            "description": "Bytes received by the container.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.network.io.usage.rx_dropped": {
            "attributes": [
               "interface"
            ],
            "description": "Incoming packets dropped.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "container.network.io.usage.rx_errors": {
            "attributes": [
               "interface"
            ],
            "description": "Received errors.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "container.network.io.usage.rx_packets": {
            "attributes": [
               "interface"
            ],
            "description": "Packets received.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "container.network.io.usage.tx_bytes": {
            "attributes": [
               "interface"
            ],
            "description": "Bytes sent.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.network.io.usage.tx_dropped": {
            "attributes": [
               "interface"
            ],
            "description": "Outgoing packets dropped.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "container.network.io.usage.tx_errors": {
            "attributes": [
               "interface"
            ],
            "description": "Sent errors.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "container.network.io.usage.tx_packets": {
            "attributes": [
               "interface"
            ],
            "description": "Packets sent.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "container.pids.count": {
            "description": "Number of pids in the container's cgroup.",
            "enabled": false,
            "extended_documentation": "It requires docker API 1.23 or higher and kernel version >= 4.3 with pids cgroup supported. [More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/pids.txt)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{pids}"
         },
         "container.pids.limit": {
            "description": "Maximum number of pids in the container's cgroup.",
            "enabled": false,
            "extended_documentation": "It requires docker API 1.23 or higher and kernel version >= 4.3 with pids cgroup supported. [More docs](https://www.kernel.org/doc/Documentation/cgroup-v1/pids.txt)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{pids}"
         },
         "container.restarts": {
            "description": "Number of restarts for the container.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{restarts}"
         },
         "container.uptime": {
            "description": "Time elapsed since container start time.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         }
      },
      "resource_attributes": {
         "container.command_line": {
            "description": "The full command executed by the container.",
            "enabled": false,
            "type": "string"
         },
         "container.hostname": {
            "description": "The hostname of the container.",
            "enabled": true,
            "type": "string"
         },
         "container.id": {
            "description": "The ID of the container.",
            "enabled": true,
            "type": "string"
         },
         "container.image.id": {
            "description": "The ID of the container image.",
            "enabled": false,
            "type": "string"
         },
         "container.image.name": {
            "description": "The name of the docker image in use by the container.",
            "enabled": true,
            "type": "string"
         },
         "container.name": {
            "description": "The name of the container.",
            "enabled": true,
            "type": "string"
         },
         "container.runtime": {
            "description": "The runtime of the container. For this receiver, it will always be 'docker'.",
            "enabled": true,
            "type": "string"
         }
      },
      "sem_conv_version": "1.6.1",
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "rmfitzpatrick",
               "jamesmoessis"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "type": "docker_stats"
   },
   "dynatraceexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "dyladan",
               "arminru",
               "evan-bradley"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "observiq"
         ],
         "stability": {
            "deprecated": [
               "metrics"
            ]
         }
      },
      "type": "dynatrace"
   },
   "ec2": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.account.id": {
            "description": "The cloud account id",
            "enabled": true,
            "type": "string"
         },
         "cloud.availability_zone": {
            "description": "The cloud availability zone",
            "enabled": true,
            "type": "string"
         },
         "cloud.platform": {
            "description": "The cloud platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud region",
            "enabled": true,
            "type": "string"
         },
         "host.id": {
            "description": "The host.id",
            "enabled": true,
            "type": "string"
         },
         "host.image.id": {
            "description": "The host image id",
            "enabled": true,
            "type": "string"
         },
         "host.name": {
            "description": "The hostname",
            "enabled": true,
            "type": "string"
         },
         "host.type": {
            "description": "The host id",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/ec2"
   },
   "ecs": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "aws.ecs.cluster.arn": {
            "description": "The aws.ecs.cluster.arn",
            "enabled": true,
            "type": "string"
         },
         "aws.ecs.launchtype": {
            "description": "The aws.ecs.launchtype",
            "enabled": true,
            "type": "string"
         },
         "aws.ecs.task.arn": {
            "description": "The aws.ecs.task.arn",
            "enabled": true,
            "type": "string"
         },
         "aws.ecs.task.family": {
            "description": "The aws.ecs.task.family",
            "enabled": true,
            "type": "string"
         },
         "aws.ecs.task.id": {
            "description": "The aws.ecs.task.id",
            "enabled": true,
            "type": "string"
         },
         "aws.ecs.task.revision": {
            "description": "The aws.ecs.task.revision",
            "enabled": true,
            "type": "string"
         },
         "aws.log.group.arns": {
            "description": "The aws.log.group.arns",
            "enabled": true,
            "type": "slice"
         },
         "aws.log.group.names": {
            "description": "The aws.log.group.names",
            "enabled": true,
            "type": "slice"
         },
         "aws.log.stream.arns": {
            "description": "The aws.log.stream.arns",
            "enabled": true,
            "type": "slice"
         },
         "aws.log.stream.names": {
            "description": "The aws.log.stream.names",
            "enabled": true,
            "type": "slice"
         },
         "cloud.account.id": {
            "description": "The cloud.account.id",
            "enabled": true,
            "type": "string"
         },
         "cloud.availability_zone": {
            "description": "The cloud.availability_zone",
            "enabled": true,
            "type": "string"
         },
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud.region",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/ecs"
   },
   "eks": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "k8s.cluster.name": {
            "description": "The EKS cluster name. This attribute is currently only available when running on EC2 instances, and requires permission to run the EC2:DescribeInstances action.",
            "enabled": false,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/eks"
   },
   "elasticbeanstalk": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "deployment.environment": {
            "description": "The deployment.environment",
            "enabled": true,
            "type": "string"
         },
         "service.instance.id": {
            "description": "The service.instance.id",
            "enabled": true,
            "type": "string"
         },
         "service.version": {
            "description": "The service.version",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/elastic_beanstalk"
   },
   "elasticsearchexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "JaredTan95"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "logs"
            ]
         }
      },
      "type": "elasticsearch"
   },
   "elasticsearchreceiver": {
      "attributes": {
         "cache_name": {
            "description": "The name of cache.",
            "enum": [
               "fielddata",
               "query"
            ],
            "type": "string"
         },
         "circuit_breaker_name": {
            "description": "The name of circuit breaker.",
            "name_override": "name",
            "type": "string"
         },
         "cluster_published_difference_state": {
            "description": "State of the published differences",
            "enum": [
               "incompatible",
               "compatible"
            ],
            "name_override": "state",
            "type": "string"
         },
         "cluster_state_queue_state": {
            "description": "State of the published differences",
            "enum": [
               "pending",
               "committed"
            ],
            "name_override": "state",
            "type": "string"
         },
         "cluster_state_update_state": {
            "description": "State of cluster state update",
            "name_override": "state",
            "type": "string"
         },
         "cluster_state_update_type": {
            "description": "Type of cluster state update",
            "enum": [
               "computation",
               "context_construction",
               "commit",
               "completion",
               "master_apply",
               "notification"
            ],
            "name_override": "type",
            "type": "string"
         },
         "collector_name": {
            "description": "The name of the garbage collector.",
            "name_override": "name",
            "type": "string"
         },
         "direction": {
            "description": "The direction of network data.",
            "enum": [
               "received",
               "sent"
            ],
            "type": "string"
         },
         "document_state": {
            "description": "The state of the document.",
            "enum": [
               "active",
               "deleted"
            ],
            "name_override": "state",
            "type": "string"
         },
         "get_result": {
            "description": "Result of get operation",
            "enum": [
               "hit",
               "miss"
            ],
            "name_override": "result",
            "type": "string"
         },
         "health_status": {
            "description": "The health status of the cluster.",
            "enum": [
               "green",
               "yellow",
               "red"
            ],
            "name_override": "status",
            "type": "string"
         },
         "index_aggregation_type": {
            "description": "Type of shard aggregation for index statistics",
            "enum": [
               "primary_shards",
               "total"
            ],
            "name_override": "aggregation",
            "type": "string"
         },
         "indexing_pressure_stage": {
            "description": "Stage of the indexing pressure",
            "enum": [
               "coordinating",
               "primary",
               "replica"
            ],
            "name_override": "stage",
            "type": "string"
         },
         "ingest_pipeline_name": {
            "description": "Name of the ingest pipeline.",
            "name_override": "name",
            "type": "string"
         },
         "memory_pool_name": {
            "description": "The name of the JVM memory pool.",
            "name_override": "name",
            "type": "string"
         },
         "memory_state": {
            "description": "State of the memory",
            "enum": [
               "free",
               "used"
            ],
            "name_override": "state",
            "type": "string"
         },
         "operation": {
            "description": "The type of operation.",
            "enum": [
               "index",
               "delete",
               "get",
               "query",
               "fetch",
               "scroll",
               "suggest",
               "merge",
               "refresh",
               "flush",
               "warmer"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "query_cache_count_type": {
            "description": "Type of query cache count",
            "enum": [
               "hit",
               "miss"
            ],
            "name_override": "type",
            "type": "string"
         },
         "segments_memory_object_type": {
            "description": "Type of object in segment",
            "enum": [
               "term",
               "doc_value",
               "index_writer",
               "fixed_bit_set"
            ],
            "name_override": "object",
            "type": "string"
         },
         "shard_state": {
            "description": "The state of the shard.",
            "enum": [
               "active",
               "active_primary",
               "relocating",
               "initializing",
               "unassigned",
               "unassigned_delayed"
            ],
            "name_override": "state",
            "type": "string"
         },
         "task_state": {
            "description": "The state of the task.",
            "enum": [
               "rejected",
               "completed"
            ],
            "name_override": "state",
            "type": "string"
         },
         "thread_pool_name": {
            "description": "The name of the thread pool.",
            "type": "string"
         },
         "thread_state": {
            "description": "The state of the thread.",
            "enum": [
               "active",
               "idle"
            ],
            "name_override": "state",
            "type": "string"
         }
      },
      "metrics": {
         "elasticsearch.breaker.memory.estimated": {
            "attributes": [
               "circuit_breaker_name"
            ],
            "description": "Estimated memory used for the operation.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.breaker.memory.limit": {
            "attributes": [
               "circuit_breaker_name"
            ],
            "description": "Memory limit for the circuit breaker.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.breaker.tripped": {
            "attributes": [
               "circuit_breaker_name"
            ],
            "description": "Total number of times the circuit breaker has been triggered and prevented an out of memory error.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.cluster.data_nodes": {
            "attributes": [ ],
            "description": "The number of data nodes in the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{nodes}"
         },
         "elasticsearch.cluster.health": {
            "attributes": [
               "health_status"
            ],
            "description": "The health status of the cluster.",
            "enabled": true,
            "extended_documentation": "Health status is based on the state of its primary and replica shards. Green indicates all shards are assigned. Yellow indicates that one or more replica shards are unassigned. Red indicates that one or more primary shards are unassigned, making some data unavailable.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{status}"
         },
         "elasticsearch.cluster.in_flight_fetch": {
            "attributes": [ ],
            "description": "The number of unfinished fetches.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{fetches}"
         },
         "elasticsearch.cluster.indices.cache.evictions": {
            "attributes": [
               "cache_name"
            ],
            "description": "The number of evictions from the cache for indices in cluster.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{evictions}"
         },
         "elasticsearch.cluster.nodes": {
            "attributes": [ ],
            "description": "The total number of nodes in the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{nodes}"
         },
         "elasticsearch.cluster.pending_tasks": {
            "attributes": [ ],
            "description": "The number of cluster-level changes that have not yet been executed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{tasks}"
         },
         "elasticsearch.cluster.published_states.differences": {
            "attributes": [
               "cluster_published_difference_state"
            ],
            "description": "Number of differences between published cluster states.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.cluster.published_states.full": {
            "attributes": [ ],
            "description": "Number of published cluster states.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.cluster.shards": {
            "attributes": [
               "shard_state"
            ],
            "description": "The number of shards in the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{shards}"
         },
         "elasticsearch.cluster.state_queue": {
            "attributes": [
               "cluster_state_queue_state"
            ],
            "description": "Number of cluster states in queue.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.cluster.state_update.count": {
            "attributes": [
               "cluster_state_update_state"
            ],
            "description": "The number of cluster state update attempts that changed the cluster state since the node started.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.cluster.state_update.time": {
            "attributes": [
               "cluster_state_update_state",
               "cluster_state_update_type"
            ],
            "description": "The cumulative amount of time updating the cluster state since the node started.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "elasticsearch.index.cache.evictions": {
            "attributes": [
               "cache_name",
               "index_aggregation_type"
            ],
            "description": "The number of evictions from the cache for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{evictions}"
         },
         "elasticsearch.index.cache.memory.usage": {
            "attributes": [
               "cache_name",
               "index_aggregation_type"
            ],
            "description": "The size in bytes of the cache for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.index.cache.size": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "The number of elements of the query cache for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.index.documents": {
            "attributes": [
               "document_state",
               "index_aggregation_type"
            ],
            "description": "The number of documents for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.index.operations.completed": {
            "attributes": [
               "operation",
               "index_aggregation_type"
            ],
            "description": "The number of operations completed for an index.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "elasticsearch.index.operations.merge.docs_count": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "The total number of documents in merge operations for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.index.operations.merge.size": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "The total size of merged segments for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.index.operations.time": {
            "attributes": [
               "operation",
               "index_aggregation_type"
            ],
            "description": "Time spent on operations for an index.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "elasticsearch.index.segments.count": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "Number of segments of an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{segments}"
         },
         "elasticsearch.index.segments.memory": {
            "attributes": [
               "index_aggregation_type",
               "segments_memory_object_type"
            ],
            "description": "Size of memory for segment object of an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.index.segments.size": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "Size of segments of an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.index.shards.size": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "The size of the shards assigned to this index.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.index.translog.operations": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "Number of transaction log operations for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "elasticsearch.index.translog.size": {
            "attributes": [
               "index_aggregation_type"
            ],
            "description": "Size of the transaction log for an index.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.indexing_pressure.memory.limit": {
            "attributes": [ ],
            "description": "Configured memory limit, in bytes, for the indexing requests.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.indexing_pressure.memory.total.primary_rejections": {
            "attributes": [ ],
            "description": "Cumulative number of indexing requests rejected in the primary stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.indexing_pressure.memory.total.replica_rejections": {
            "attributes": [ ],
            "description": "Number of indexing requests rejected in the replica stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.memory.indexing_pressure": {
            "attributes": [
               "indexing_pressure_stage"
            ],
            "description": "Memory consumed, in bytes, by indexing requests in the specified stage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.cache.count": {
            "attributes": [
               "query_cache_count_type"
            ],
            "description": "Total count of query cache misses across all shards assigned to selected nodes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "elasticsearch.node.cache.evictions": {
            "attributes": [
               "cache_name"
            ],
            "description": "The number of evictions from the cache on a node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{evictions}"
         },
         "elasticsearch.node.cache.memory.usage": {
            "attributes": [
               "cache_name"
            ],
            "description": "The size in bytes of the cache on a node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.cache.size": {
            "attributes": [ ],
            "description": "Total amount of memory used for the query cache across all shards assigned to the node.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.cluster.connections": {
            "attributes": [ ],
            "description": "The number of open tcp connections for internal cluster communication.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "elasticsearch.node.cluster.io": {
            "attributes": [
               "direction"
            ],
            "description": "The number of bytes sent and received on the network for internal cluster communication.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.disk.io.read": {
            "attributes": [ ],
            "description": "The total number of kilobytes read across all file stores for this node.",
            "enabled": true,
            "extended_documentation": "This metric is available only on Linux systems.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "KiBy"
         },
         "elasticsearch.node.disk.io.write": {
            "attributes": [ ],
            "description": "The total number of kilobytes written across all file stores for this node.",
            "enabled": true,
            "extended_documentation": "This metric is available only on Linux systems.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "KiBy"
         },
         "elasticsearch.node.documents": {
            "attributes": [
               "document_state"
            ],
            "description": "The number of documents on the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.node.fs.disk.available": {
            "attributes": [ ],
            "description": "The amount of disk space available to the JVM across all file stores for this node. Depending on OS or process level restrictions, this might appear less than free. This is the actual amount of free disk space the Elasticsearch node can utilise.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.fs.disk.free": {
            "attributes": [ ],
            "description": "The amount of unallocated disk space across all file stores for this node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.fs.disk.total": {
            "attributes": [ ],
            "description": "The amount of disk space across all file stores for this node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.http.connections": {
            "attributes": [ ],
            "description": "The number of HTTP connections to the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "elasticsearch.node.ingest.documents": {
            "attributes": [ ],
            "description": "Total number of documents ingested during the lifetime of this node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.node.ingest.documents.current": {
            "attributes": [ ],
            "description": "Total number of documents currently being ingested.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.node.ingest.operations.failed": {
            "attributes": [ ],
            "description": "Total number of failed ingest operations during the lifetime of this node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operation}"
         },
         "elasticsearch.node.open_files": {
            "attributes": [ ],
            "description": "The number of open file descriptors held by the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{files}"
         },
         "elasticsearch.node.operations.completed": {
            "attributes": [
               "operation"
            ],
            "description": "The number of operations completed by a node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "elasticsearch.node.operations.current": {
            "attributes": [
               "operation"
            ],
            "description": "Number of query operations currently running.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "elasticsearch.node.operations.get.completed": {
            "attributes": [
               "get_result"
            ],
            "description": "The number of hits and misses resulting from GET operations.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "elasticsearch.node.operations.get.time": {
            "attributes": [
               "get_result"
            ],
            "description": "The time spent on hits and misses resulting from GET operations.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "elasticsearch.node.operations.time": {
            "attributes": [
               "operation"
            ],
            "description": "Time spent on operations by a node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "elasticsearch.node.pipeline.ingest.documents.current": {
            "attributes": [
               "ingest_pipeline_name"
            ],
            "description": "Total number of documents currently being ingested by a pipeline.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.node.pipeline.ingest.documents.preprocessed": {
            "attributes": [
               "ingest_pipeline_name"
            ],
            "description": "Number of documents preprocessed by the ingest pipeline.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "elasticsearch.node.pipeline.ingest.operations.failed": {
            "attributes": [
               "ingest_pipeline_name"
            ],
            "description": "Total number of failed operations for the ingest pipeline.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operation}"
         },
         "elasticsearch.node.script.cache_evictions": {
            "attributes": [ ],
            "description": "Total number of times the script cache has evicted old data.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.node.script.compilation_limit_triggered": {
            "attributes": [ ],
            "description": "Total number of times the script compilation circuit breaker has limited inline script compilations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "elasticsearch.node.script.compilations": {
            "attributes": [ ],
            "description": "Total number of inline script compilations performed by the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{compilations}"
         },
         "elasticsearch.node.segments.memory": {
            "attributes": [
               "segments_memory_object_type"
            ],
            "description": "Size of memory for segment object of a node.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.shards.data_set.size": {
            "attributes": [ ],
            "description": "Total data set size of all shards assigned to the node. This includes the size of shards not stored fully on the node, such as the cache for partially mounted indices.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.shards.reserved.size": {
            "attributes": [ ],
            "description": "A prediction of how much larger the shard stores on this node will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities. A value of -1 indicates that this is not available.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.shards.size": {
            "attributes": [ ],
            "description": "The size of the shards assigned to this node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.thread_pool.tasks.finished": {
            "attributes": [
               "thread_pool_name",
               "task_state"
            ],
            "description": "The number of tasks finished by the thread pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{tasks}"
         },
         "elasticsearch.node.thread_pool.tasks.queued": {
            "attributes": [
               "thread_pool_name"
            ],
            "description": "The number of queued tasks in the thread pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{tasks}"
         },
         "elasticsearch.node.thread_pool.threads": {
            "attributes": [
               "thread_pool_name",
               "thread_state"
            ],
            "description": "The number of threads in the thread pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         },
         "elasticsearch.node.translog.operations": {
            "attributes": [ ],
            "description": "Number of transaction log operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "elasticsearch.node.translog.size": {
            "attributes": [ ],
            "description": "Size of the transaction log.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.node.translog.uncommitted.size": {
            "attributes": [ ],
            "description": "Size of uncommitted transaction log operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.os.cpu.load_avg.15m": {
            "attributes": [ ],
            "description": "Fifteen-minute load average on the system (field is not present if fifteen-minute load average is not available).",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "elasticsearch.os.cpu.load_avg.1m": {
            "attributes": [ ],
            "description": "One-minute load average on the system (field is not present if one-minute load average is not available).",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "elasticsearch.os.cpu.load_avg.5m": {
            "attributes": [ ],
            "description": "Five-minute load average on the system (field is not present if five-minute load average is not available).",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "elasticsearch.os.cpu.usage": {
            "attributes": [ ],
            "description": "Recent CPU usage for the whole system, or -1 if not supported.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "%"
         },
         "elasticsearch.os.memory": {
            "attributes": [
               "memory_state"
            ],
            "description": "Amount of physical memory.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "elasticsearch.process.cpu.time": {
            "attributes": [ ],
            "description": "CPU time used by the process on which the Java virtual machine is running.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "elasticsearch.process.cpu.usage": {
            "attributes": [ ],
            "description": "CPU usage in percent.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "elasticsearch.process.memory.virtual": {
            "attributes": [ ],
            "description": "Size of virtual memory that is guaranteed to be available to the running process.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.classes.loaded": {
            "attributes": [ ],
            "description": "The number of loaded classes",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "jvm.gc.collections.count": {
            "attributes": [
               "collector_name"
            ],
            "description": "The total number of garbage collections that have occurred",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "jvm.gc.collections.elapsed": {
            "attributes": [
               "collector_name"
            ],
            "description": "The approximate accumulated collection elapsed time",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "jvm.memory.heap.committed": {
            "attributes": [ ],
            "description": "The amount of memory that is guaranteed to be available for the heap",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.memory.heap.max": {
            "attributes": [ ],
            "description": "The maximum amount of memory can be used for the heap",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.memory.heap.used": {
            "attributes": [ ],
            "description": "The current heap memory usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.memory.heap.utilization": {
            "attributes": [ ],
            "description": "Fraction of heap memory usage",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "jvm.memory.nonheap.committed": {
            "attributes": [ ],
            "description": "The amount of memory that is guaranteed to be available for non-heap purposes",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.memory.nonheap.used": {
            "attributes": [ ],
            "description": "The current non-heap memory usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.memory.pool.max": {
            "attributes": [
               "memory_pool_name"
            ],
            "description": "The maximum amount of memory can be used for the memory pool",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.memory.pool.used": {
            "attributes": [
               "memory_pool_name"
            ],
            "description": "The current memory pool memory usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "jvm.threads.count": {
            "attributes": [ ],
            "description": "The current number of threads",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         }
      },
      "resource_attributes": {
         "elasticsearch.cluster.name": {
            "description": "The name of the elasticsearch cluster.",
            "enabled": true,
            "type": "string"
         },
         "elasticsearch.index.name": {
            "description": "The name of the elasticsearch index.",
            "enabled": true,
            "type": "string"
         },
         "elasticsearch.node.name": {
            "description": "The name of the elasticsearch node.",
            "enabled": true,
            "type": "string"
         },
         "elasticsearch.node.version": {
            "description": "The version of the elasticsearch node.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "BinaryFissionGames"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "elasticsearch"
   },
   "expvarreceiver": {
      "metrics": {
         "process.runtime.memstats.buck_hash_sys": {
            "description": "Bytes of memory in profiling bucket hash tables.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.frees": {
            "description": "Cumulative count of heap objects freed.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{objects}"
         },
         "process.runtime.memstats.gc_cpu_fraction": {
            "description": "The fraction of this program's available CPU time used by the GC since the program started.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "process.runtime.memstats.gc_sys": {
            "description": "Bytes of memory in garbage collection metadata.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.heap_alloc": {
            "description": "Bytes of allocated heap objects.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.heap_idle": {
            "description": "Bytes in idle (unused) spans.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.heap_inuse": {
            "description": "Bytes in in-use spans.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.heap_objects": {
            "description": "Number of allocated heap objects.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{objects}"
         },
         "process.runtime.memstats.heap_released": {
            "description": "Bytes of physical memory returned to the OS.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.heap_sys": {
            "description": "Bytes of heap memory obtained by the OS.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.last_pause": {
            "description": "The most recent stop-the-world pause time.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "gauge": {
               "value_type": "int"
            },
            "unit": "ns"
         },
         "process.runtime.memstats.lookups": {
            "description": "Number of pointer lookups performed by the runtime.",
            "enabled": false,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{lookups}"
         },
         "process.runtime.memstats.mallocs": {
            "description": "Cumulative count of heap objects allocated.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{objects}"
         },
         "process.runtime.memstats.mcache_inuse": {
            "description": "Bytes of allocated mcache structures.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.mcache_sys": {
            "description": "Bytes of memory obtained from the OS for mcache structures.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.mspan_inuse": {
            "description": "Bytes of allocated mspan structures.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.mspan_sys": {
            "description": "Bytes of memory obtained from the OS for mspan structures.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.next_gc": {
            "description": "The target heap size of the next GC cycle.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.num_forced_gc": {
            "description": "Number of GC cycles that were forced by the application calling the GC function.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.num_gc": {
            "description": "Number of completed GC cycles.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.other_sys": {
            "description": "Bytes of memory in miscellaneous off-heap runtime allocations.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.pause_total": {
            "description": "The cumulative nanoseconds in GC stop-the-world pauses since the program started.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.stack_inuse": {
            "description": "Bytes in stack spans.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.stack_sys": {
            "description": "Bytes of stack memory obtained from the OS.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.sys": {
            "description": "Total bytes of memory obtained from the OS.",
            "enabled": true,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.runtime.memstats.total_alloc": {
            "description": "Cumulative bytes allocated for heap objects.",
            "enabled": false,
            "extended_documentation": "As defined by https://pkg.go.dev/runtime#MemStats",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "jamesmoessis",
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "expvar"
   },
   "f5cloudexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "gramidt"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "f5cloud"
   },
   "fileexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "atingchen"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "aws"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "file"
   },
   "filelogreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "type": "filelog"
   },
   "filereceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "pmcollins",
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "type": "file"
   },
   "filestatsreceiver": {
      "attributes": {
         "file.permissions": {
            "description": "the permissions associated with the file, using an octal format.",
            "type": "string"
         }
      },
      "metrics": {
         "file.atime": {
            "description": "Elapsed time since last access of the file or folder, in seconds since Epoch.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "s"
         },
         "file.count": {
            "description": "The number of files matched",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{file}"
         },
         "file.ctime": {
            "attributes": [
               "file.permissions"
            ],
            "description": "Elapsed time since the last change of the file or folder, in seconds since Epoch. In addition to `file.mtime`, this metric tracks metadata changes such as permissions or renaming the file.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "s"
         },
         "file.mtime": {
            "description": "Elapsed time since the last modification of the file or folder, in seconds since Epoch.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "s"
         },
         "file.size": {
            "description": "The size of the file or folder, in bytes.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "b"
         }
      },
      "resource_attributes": {
         "file.name": {
            "description": "The name of the file",
            "enabled": true,
            "type": "string"
         },
         "file.path": {
            "description": "The absolute path of the file",
            "enabled": false,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "filestats"
   },
   "filesystemscraper": {
      "attributes": {
         "device": {
            "description": "Identifier of the filesystem.",
            "type": "string"
         },
         "mode": {
            "description": "Mountpoint mode such \"ro\", \"rw\", etc.",
            "type": "string"
         },
         "mountpoint": {
            "description": "Mountpoint path.",
            "type": "string"
         },
         "state": {
            "description": "Breakdown of filesystem usage by type.",
            "enum": [
               "free",
               "reserved",
               "used"
            ],
            "type": "string"
         },
         "type": {
            "description": "Filesystem type, such as, \"ext4\", \"tmpfs\", etc.",
            "type": "string"
         }
      },
      "metrics": {
         "system.filesystem.inodes.usage": {
            "attributes": [
               "device",
               "mode",
               "mountpoint",
               "type",
               "state"
            ],
            "description": "FileSystem inodes used.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{inodes}"
         },
         "system.filesystem.usage": {
            "attributes": [
               "device",
               "mode",
               "mountpoint",
               "type",
               "state"
            ],
            "description": "Filesystem bytes used.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.filesystem.utilization": {
            "attributes": [
               "device",
               "mode",
               "mountpoint",
               "type"
            ],
            "description": "Fraction of filesystem bytes used.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/filesystem"
   },
   "filterprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "TylerHelmuth",
               "boostchicken"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "splunk",
            "observiq",
            "sumo",
            "aws",
            "redhat",
            "liatrio"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         },
         "warnings": [
            "Orphaned Telemetry",
            "Other"
         ]
      },
      "tests": {
         "config": null
      },
      "type": "filter"
   },
   "flinkmetricsreceiver": {
      "attributes": {
         "checkpoint": {
            "description": "The number of checkpoints completed or that failed.",
            "enum": [
               "completed",
               "failed"
            ],
            "type": "string"
         },
         "garbage_collector_name": {
            "description": "The names for the parallel scavenge and garbage first garbage collectors.",
            "enum": [
               "PS_MarkSweep",
               "PS_Scavenge",
               "G1_Young_Generation",
               "G1_Old_Generation"
            ],
            "name_override": "name",
            "type": "string"
         },
         "operator_name": {
            "description": "The operator name.",
            "name_override": "name",
            "type": "string"
         },
         "record": {
            "description": "The number of records received in, sent out or dropped due to arriving late.",
            "enum": [
               "in",
               "out",
               "dropped"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "flink.job.checkpoint.count": {
            "attributes": [
               "checkpoint"
            ],
            "description": "The number of checkpoints completed or failed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{checkpoints}"
         },
         "flink.job.checkpoint.in_progress": {
            "attributes": [ ],
            "description": "The number of checkpoints in progress.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{checkpoints}"
         },
         "flink.job.last_checkpoint.size": {
            "attributes": [ ],
            "description": "The total size of the last checkpoint.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.job.last_checkpoint.time": {
            "attributes": [ ],
            "description": "The end to end duration of the last checkpoint.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "ms"
         },
         "flink.job.restart.count": {
            "attributes": [ ],
            "description": "The total number of restarts since this job was submitted, including full restarts and fine-grained restarts.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{restarts}"
         },
         "flink.jvm.class_loader.classes_loaded": {
            "attributes": [ ],
            "description": "The total number of classes loaded since the start of the JVM.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{classes}"
         },
         "flink.jvm.cpu.load": {
            "attributes": [ ],
            "description": "The CPU usage of the JVM for a jobmanager or taskmanager.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "%"
         },
         "flink.jvm.cpu.time": {
            "attributes": [ ],
            "description": "The CPU time used by the JVM for a jobmanager or taskmanager.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "flink.jvm.gc.collections.count": {
            "attributes": [
               "garbage_collector_name"
            ],
            "description": "The total number of collections that have occurred.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{collections}"
         },
         "flink.jvm.gc.collections.time": {
            "attributes": [
               "garbage_collector_name"
            ],
            "description": "The total time spent performing garbage collection.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "flink.jvm.memory.direct.total_capacity": {
            "attributes": [ ],
            "description": "The total capacity of all buffers in the direct buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.direct.used": {
            "attributes": [ ],
            "description": "The amount of memory used by the JVM for the direct buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.heap.committed": {
            "attributes": [ ],
            "description": "The amount of heap memory guaranteed to be available to the JVM.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.heap.max": {
            "attributes": [ ],
            "description": "The maximum amount of heap memory that can be used for memory management.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.heap.used": {
            "attributes": [ ],
            "description": "The amount of heap memory currently used.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.mapped.total_capacity": {
            "attributes": [ ],
            "description": "The number of buffers in the mapped buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.mapped.used": {
            "attributes": [ ],
            "description": "The amount of memory used by the JVM for the mapped buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.metaspace.committed": {
            "attributes": [ ],
            "description": "The amount of memory guaranteed to be available to the JVM in the Metaspace memory pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.metaspace.max": {
            "attributes": [ ],
            "description": "The maximum amount of memory that can be used in the Metaspace memory pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.metaspace.used": {
            "attributes": [ ],
            "description": "The amount of memory currently used in the Metaspace memory pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.nonheap.committed": {
            "attributes": [ ],
            "description": "The amount of non-heap memory guaranteed to be available to the JVM.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.nonheap.max": {
            "attributes": [ ],
            "description": "The maximum amount of non-heap memory that can be used for memory management.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.memory.nonheap.used": {
            "attributes": [ ],
            "description": "The amount of non-heap memory currently used.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.jvm.threads.count": {
            "attributes": [ ],
            "description": "The total number of live threads.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         },
         "flink.memory.managed.total": {
            "attributes": [ ],
            "description": "The total amount of managed memory.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.memory.managed.used": {
            "attributes": [ ],
            "description": "The amount of managed memory currently used.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "flink.operator.record.count": {
            "attributes": [
               "operator_name",
               "record"
            ],
            "description": "The number of records an operator has.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{records}"
         },
         "flink.operator.watermark.output": {
            "attributes": [
               "operator_name"
            ],
            "description": "The last watermark this operator has emitted.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "flink.task.record.count": {
            "attributes": [
               "record"
            ],
            "description": "The number of records a task has.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{records}"
         }
      },
      "resource_attributes": {
         "flink.job.name": {
            "description": "The job name.",
            "enabled": true,
            "type": "string"
         },
         "flink.resource.type": {
            "description": "The flink scope type in which a metric belongs to.",
            "enabled": true,
            "enum": [
               "jobmanager",
               "taskmanager"
            ],
            "type": "string"
         },
         "flink.subtask.index": {
            "description": "The subtask index.",
            "enabled": true,
            "type": "string"
         },
         "flink.task.name": {
            "description": "The task name.",
            "enabled": true,
            "type": "string"
         },
         "flink.taskmanager.id": {
            "description": "The taskmanager ID.",
            "enabled": true,
            "type": "string"
         },
         "host.name": {
            "description": "The host name.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "JonathanWamsley",
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "flinkmetrics"
   },
   "fluentforwardreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "fluentforward"
   },
   "gcp": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.account.id": {
            "description": "The cloud.account.id",
            "enabled": true,
            "type": "string"
         },
         "cloud.availability_zone": {
            "description": "The cloud.availability_zone",
            "enabled": true,
            "type": "string"
         },
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud.region",
            "enabled": true,
            "type": "string"
         },
         "faas.id": {
            "description": "The faas.id.",
            "enabled": true,
            "type": "string"
         },
         "faas.instance": {
            "description": "The faas.instance",
            "enabled": true,
            "type": "string"
         },
         "faas.name": {
            "description": "faas.name",
            "enabled": true,
            "type": "string"
         },
         "faas.version": {
            "description": "The faas.version",
            "enabled": true,
            "type": "string"
         },
         "gcp.cloud_run.job.execution": {
            "description": "The Job execution name",
            "enabled": true,
            "type": "string"
         },
         "gcp.cloud_run.job.task_index": {
            "description": "The Job execution task index",
            "enabled": true,
            "type": "string"
         },
         "gcp.gce.instance.hostname": {
            "description": "The hostname of the GCE instance.",
            "enabled": false,
            "type": "string"
         },
         "gcp.gce.instance.name": {
            "description": "The name of the GCE instance.",
            "enabled": false,
            "type": "string"
         },
         "host.id": {
            "description": "The host.id",
            "enabled": true,
            "type": "string"
         },
         "host.name": {
            "description": "The host.name",
            "enabled": true,
            "type": "string"
         },
         "host.type": {
            "description": "The host.type",
            "enabled": true,
            "type": "string"
         },
         "k8s.cluster.name": {
            "description": "The k8s.cluster.name",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/gcp"
   },
   "gitproviderreceiver": {
      "attributes": {
         "repository.name": {
            "description": "The full name of the Git repository",
            "type": "string"
         }
      },
      "metrics": {
         "git.repository.branch.count": {
            "attributes": [
               "repository.name"
            ],
            "description": "Number of branches in the repository",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "git.repository.contributor.count": {
            "attributes": [
               "repository.name"
            ],
            "description": "Total number of unique contributors to this repository",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "git.repository.count": {
            "attributes": [ ],
            "description": "Number of repositories in an organization",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         }
      },
      "resource_attributes": {
         "git.vendor.name": {
            "description": "The name of the Git vendor/provider (ie. GitHub / GitLab)",
            "enabled": true,
            "type": "string"
         },
         "organization.name": {
            "description": "Git Organization or Project Name",
            "enabled": true,
            "type": "string"
         }
      },
      "sem_conv_version": "1.9.0",
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "adrielp",
               "astencel-sumo"
            ]
         },
         "distributions": [
            "liatrio"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "type": "gitprovider"
   },
   "googlecloudexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "aabmass",
               "dashpole",
               "jsuereth",
               "punya",
               "damemi",
               "psx95"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "googlecloud"
   },
   "googlecloudpubsubexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "alexvanboxel"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "googlecloudpubsub"
   },
   "googlecloudpubsubreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "alexvanboxel"
            ]
         },
         "distributions": [
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces",
               "logs",
               "metrics"
            ]
         }
      },
      "tests": {
         "config": {
            "project": "my-project",
            "subscription": "projects/my-project/subscriptions/otlp-subscription",
            "timeout": "20s",
            "user_agent": "user-agent"
         },
         "skip_lifecycle": true
      },
      "type": "googlecloudpubsub"
   },
   "googlecloudspannerreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "varunraiko"
            ],
            "emeritus": [
               "architjugran",
               "kiranmayib"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "googlecloudspanner"
   },
   "googlemanagedprometheusexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "aabmass",
               "dashpole",
               "jsuereth",
               "punya",
               "damemi",
               "psx95"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "googlemanagedprometheus"
   },
   "groupbyattrsprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "rnishtala-sumo"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         },
         "warnings": [ ]
      },
      "tests": {
         "config": null
      },
      "type": "groupbyattrs"
   },
   "groupbytraceprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "jpkrohling"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo",
            "aws"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         },
         "warnings": [
            "Statefulness"
         ]
      },
      "tests": {
         "config": null
      },
      "type": "groupbytrace"
   },
   "haproxyreceiver": {
      "attributes": {
         "status_code": {
            "description": "Status code category, 1xx, 2xx, 3xx, 4xx, 5xx or other",
            "enum": [
               "1xx",
               "2xx",
               "3xx",
               "4xx",
               "5xx",
               "other"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "haproxy.bytes.input": {
            "description": "Bytes in. Corresponds to HAProxy's `bin` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "by"
         },
         "haproxy.bytes.output": {
            "description": "Bytes out. Corresponds to HAProxy's `bout` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "by"
         },
         "haproxy.clients.canceled": {
            "description": "Number of data transfers aborted by the client. Corresponds to HAProxy's `cli_abrt` metric",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{cancellations}"
         },
         "haproxy.compression.bypass": {
            "description": "Number of bytes that bypassed the HTTP compressor (CPU/BW limit). Corresponds to HAProxy's `comp_byp` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "by"
         },
         "haproxy.compression.count": {
            "description": "Number of HTTP responses that were compressed. Corresponds to HAProxy's `comp_rsp` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{responses}"
         },
         "haproxy.compression.input": {
            "description": "Number of HTTP response bytes fed to the compressor. Corresponds to HAProxy's `comp_in` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "by"
         },
         "haproxy.compression.output": {
            "description": "Number of HTTP response bytes emitted by the compressor. Corresponds to HAProxy's `comp_out` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "by"
         },
         "haproxy.connections.errors": {
            "description": "Number of requests that encountered an error trying to connect to a backend server. The backend stat is the sum of the stat. Corresponds to HAProxy's `econ` metric",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "haproxy.connections.rate": {
            "description": "Number of connections over the last elapsed second (frontend). Corresponds to HAProxy's `conn_rate` metric.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "haproxy.connections.retries": {
            "description": "Number of times a connection to a server was retried. Corresponds to HAProxy's `wretr` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{retries}"
         },
         "haproxy.connections.total": {
            "description": "Cumulative number of connections (frontend). Corresponds to HAProxy's `conn_tot` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "haproxy.downtime": {
            "description": "Total downtime (in seconds). The value for the backend is the downtime for the whole backend, not the sum of the server downtime. Corresponds to HAProxy's `downtime` metric",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         },
         "haproxy.failed_checks": {
            "description": "Number of failed checks. (Only counts checks failed when the server is up). Corresponds to HAProxy's `chkfail` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{checks}"
         },
         "haproxy.requests.denied": {
            "description": "Requests denied because of security concerns. Corresponds to HAProxy's `dreq` metric",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "haproxy.requests.errors": {
            "description": "Cumulative number of request errors. Corresponds to HAProxy's `ereq` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "haproxy.requests.queued": {
            "description": "Current queued requests. For the backend this reports the number queued without a server assigned. Corresponds to HAProxy's `qcur` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "haproxy.requests.rate": {
            "description": "HTTP requests per second over last elapsed second. Corresponds to HAProxy's `req_rate` metric.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "{requests}"
         },
         "haproxy.requests.redispatched": {
            "description": "Number of times a request was redispatched to another server. Corresponds to HAProxy's `wredis` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "haproxy.requests.total": {
            "attributes": [
               "status_code"
            ],
            "description": "Total number of HTTP requests received. Corresponds to HAProxy's `req_tot`, `hrsp_1xx`, `hrsp_2xx`, `hrsp_3xx`, `hrsp_4xx`, `hrsp_5xx` and `hrsp_other` metrics.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "haproxy.responses.denied": {
            "description": "Responses denied because of security concerns. Corresponds to HAProxy's `dresp` metric",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{responses}"
         },
         "haproxy.responses.errors": {
            "description": "Cumulative number of response errors. Corresponds to HAProxy's `eresp` metric, `srv_abrt` will be counted here also.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "haproxy.server_selected.total": {
            "description": "Number of times a server was selected, either for new sessions or when re-dispatching. Corresponds to HAProxy's `lbtot` metric.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{selections}"
         },
         "haproxy.sessions.average": {
            "description": "Average total session time in ms over the last 1024 requests. Corresponds to HAProxy's `ttime` metric.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "ms"
         },
         "haproxy.sessions.count": {
            "description": "Current sessions. Corresponds to HAProxy's `scur` metric.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "haproxy.sessions.rate": {
            "description": "Number of sessions per second over last elapsed second. Corresponds to HAProxy's `rate` metric.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "{sessions}"
         },
         "haproxy.sessions.total": {
            "description": "Cumulative number of sessions. Corresponds to HAProxy's `stot` metric.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{sessions}"
         }
      },
      "resource_attributes": {
         "haproxy.addr": {
            "description": "address:port or \"unix\". IPv6 has brackets around the address.",
            "enabled": true,
            "type": "string"
         },
         "haproxy.proxy_name": {
            "description": "Proxy name",
            "enabled": true,
            "type": "string"
         },
         "haproxy.service_name": {
            "description": "Service name (FRONTEND for frontend, BACKEND for backend, any name for server/listener)",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme",
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "haproxy"
   },
   "heroku": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "heroku.app.id": {
            "description": "The heroku.app.id",
            "enabled": true,
            "type": "string"
         },
         "heroku.dyno.id": {
            "description": "The heroku.dyno.id",
            "enabled": true,
            "type": "string"
         },
         "heroku.release.commit": {
            "description": "The heroku.release.commit",
            "enabled": true,
            "type": "string"
         },
         "heroku.release.creation_timestamp": {
            "description": "The heroku.release.creation_timestamp",
            "enabled": true,
            "type": "string"
         },
         "service.instance.id": {
            "description": "The service.instance.id",
            "enabled": true,
            "type": "string"
         },
         "service.name": {
            "description": "Heroku app name recorded as service.name.",
            "enabled": true,
            "type": "string"
         },
         "service.version": {
            "description": "Heroku relese version set as service.version.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "atoulme"
            ]
         }
      },
      "type": "resourcedetectionprocessor/heroku"
   },
   "honeycombmarkerexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "TylerHelmuth",
               "fchikwekwe"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "type": "honeycombmarker"
   },
   "hostmetricsreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "braydonk"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "observiq",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "hostmetrics"
   },
   "httpcheckreceiver": {
      "attributes": {
         "error.message": {
            "description": "Error message recorded during check",
            "type": "string"
         },
         "http.method": {
            "description": "HTTP request method",
            "type": "string"
         },
         "http.status_class": {
            "description": "HTTP response status class",
            "type": "string"
         },
         "http.status_code": {
            "description": "HTTP response status code",
            "type": "int"
         },
         "http.url": {
            "description": "Full HTTP request URL.",
            "type": "string"
         }
      },
      "metrics": {
         "httpcheck.duration": {
            "attributes": [
               "http.url"
            ],
            "description": "Measures the duration of the HTTP check.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "httpcheck.error": {
            "attributes": [
               "http.url",
               "error.message"
            ],
            "description": "Records errors occurring during HTTP check.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{error}"
         },
         "httpcheck.status": {
            "attributes": [
               "http.url",
               "http.status_code",
               "http.method",
               "http.status_class"
            ],
            "description": "1 if the check resulted in status_code matching the status_class, otherwise 0.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         }
      },
      "resource_attributes": null,
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "codeboten"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         },
         "warnings": [ ]
      },
      "tests": {
         "config": null
      },
      "type": "httpcheck"
   },
   "iisreceiver": {
      "attributes": {
         "direction": {
            "description": "The direction data is moving.",
            "enum": [
               "sent",
               "received"
            ],
            "type": "string"
         },
         "request": {
            "description": "The type of request sent by a client.",
            "enum": [
               "delete",
               "get",
               "head",
               "options",
               "post",
               "put",
               "trace"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "iis.connection.active": {
            "description": "Number of active connections.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "iis.connection.anonymous": {
            "description": "Number of connections established anonymously.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "iis.connection.attempt.count": {
            "description": "Total number of attempts to connect to the server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{attempts}"
         },
         "iis.network.blocked": {
            "description": "Number of bytes blocked due to bandwidth throttling.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "iis.network.file.count": {
            "attributes": [
               "direction"
            ],
            "description": "Number of transmitted files.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{files}"
         },
         "iis.network.io": {
            "attributes": [
               "direction"
            ],
            "description": "Total amount of bytes sent and received.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "iis.request.count": {
            "attributes": [
               "request"
            ],
            "description": "Total number of requests of a given type.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "iis.request.queue.age.max": {
            "description": "Age of oldest request in the queue.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "iis.request.queue.count": {
            "description": "Current number of requests in the queue.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "iis.request.rejected": {
            "description": "Total number of requests rejected.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "iis.thread.active": {
            "description": "Current number of active threads.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         },
         "iis.uptime": {
            "description": "The amount of time the server has been up.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "s"
         }
      },
      "resource_attributes": {
         "iis.application_pool": {
            "description": "The application pool, which is associated with worker processes of one or more applications.",
            "enabled": true,
            "type": "string"
         },
         "iis.site": {
            "description": "The site of the web server.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "Mrod1598",
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "iis"
   },
   "influxdbexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "jacobmarble"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "influxdb"
   },
   "influxdbreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "jacobmarble"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "influxdb"
   },
   "instanaexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "jpkrohling",
               "hickeyma"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "traces"
            ]
         }
      },
      "type": "instana"
   },
   "jaegerreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "yurishkuro"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "redhat",
            "splunk",
            "sumo",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": {
            "protocols": {
               "grpc": null
            }
         }
      },
      "type": "jaeger"
   },
   "jmxreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "rmfitzpatrick"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "type": "jmx"
   },
   "journaldreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "sumo-drosiek",
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "type": "journald"
   },
   "k8sattributesprocessor": {
      "resource_attributes": {
         "container.id": {
            "description": "Container ID. Usually a UUID, as for example used to identify Docker containers. The UUID might be abbreviated. Requires k8s.container.restart_count.",
            "enabled": false,
            "type": "string"
         },
         "container.image.name": {
            "description": "Name of the image the container was built on. Requires container.id or k8s.container.name.",
            "enabled": true,
            "type": "string"
         },
         "container.image.tag": {
            "description": "Container image tag. Requires container.id or k8s.container.name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.cluster.uid": {
            "description": "Gives cluster uid identified with kube-system namespace",
            "enabled": false,
            "type": "string"
         },
         "k8s.container.name": {
            "description": "The name of the Container in a Pod template. Requires container.id.",
            "enabled": false,
            "type": "string"
         },
         "k8s.cronjob.name": {
            "description": "The name of the CronJob.",
            "enabled": false,
            "type": "string"
         },
         "k8s.daemonset.name": {
            "description": "The name of the DaemonSet.",
            "enabled": false,
            "type": "string"
         },
         "k8s.daemonset.uid": {
            "description": "The UID of the DaemonSet.",
            "enabled": false,
            "type": "string"
         },
         "k8s.deployment.name": {
            "description": "The name of the Deployment.",
            "enabled": true,
            "type": "string"
         },
         "k8s.deployment.uid": {
            "description": "The UID of the Deployment.",
            "enabled": false,
            "type": "string"
         },
         "k8s.job.name": {
            "description": "The name of the Job.",
            "enabled": false,
            "type": "string"
         },
         "k8s.job.uid": {
            "description": "The UID of the Job.",
            "enabled": false,
            "type": "string"
         },
         "k8s.namespace.name": {
            "description": "The name of the namespace that the pod is running in.",
            "enabled": true,
            "type": "string"
         },
         "k8s.node.name": {
            "description": "The name of the Node.",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.hostname": {
            "description": "The hostname of the Pod.",
            "enabled": false,
            "type": "string"
         },
         "k8s.pod.name": {
            "description": "The name of the Pod.",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.start_time": {
            "description": "The start time of the Pod.",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.uid": {
            "description": "The UID of the Pod.",
            "enabled": true,
            "type": "string"
         },
         "k8s.replicaset.name": {
            "description": "The name of the ReplicaSet.",
            "enabled": false,
            "type": "string"
         },
         "k8s.replicaset.uid": {
            "description": "The UID of the ReplicaSet.",
            "enabled": false,
            "type": "string"
         },
         "k8s.statefulset.name": {
            "description": "The name of the StatefulSet.",
            "enabled": false,
            "type": "string"
         },
         "k8s.statefulset.uid": {
            "description": "The UID of the StatefulSet.",
            "enabled": false,
            "type": "string"
         }
      },
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "dmitryax",
               "rmfitzpatrick",
               "fatsheep9146",
               "TylerHelmuth"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo",
            "redhat",
            "aws",
            "grafana",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "logs",
               "metrics",
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "k8sattributes"
   },
   "k8sclusterreceiver": {
      "attributes": {
         "condition": {
            "description": "the name of Kubernetes Node condition. Example: Ready, Memory, PID, DiskPressure",
            "enabled": true,
            "type": "string"
         },
         "k8s.namespace.name": {
            "description": "The k8s namespace name.",
            "enabled": true,
            "type": "string"
         },
         "resource": {
            "description": "the name of the resource on which the quota is applied",
            "enabled": true,
            "type": "string"
         }
      },
      "metrics": {
         "k8s.container.cpu_limit": {
            "description": "Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{cpu}"
         },
         "k8s.container.cpu_request": {
            "description": "Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{cpu}"
         },
         "k8s.container.ephemeralstorage_limit": {
            "description": "Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.container.ephemeralstorage_request": {
            "description": "Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.container.memory_limit": {
            "description": "Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.container.memory_request": {
            "description": "Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.container.ready": {
            "description": "Whether a container has passed its readiness probe (0 for no, 1 for yes)",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": ""
         },
         "k8s.container.restarts": {
            "description": "How many times the container has restarted in the recent past. This value is pulled directly from the K8s API and the value can go indefinitely high and be reset to 0 at any time depending on how your kubelet is configured to prune dead containers. It is best to not depend too much on the exact value but rather look at it as either == 0, in which case you can conclude there were no restarts in the recent past, or > 0, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{restart}"
         },
         "k8s.container.storage_limit": {
            "description": "Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.container.storage_request": {
            "description": "Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.cronjob.active_jobs": {
            "description": "The number of actively running jobs for a cronjob",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{job}"
         },
         "k8s.daemonset.current_scheduled_nodes": {
            "description": "Number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{node}"
         },
         "k8s.daemonset.desired_scheduled_nodes": {
            "description": "Number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{node}"
         },
         "k8s.daemonset.misscheduled_nodes": {
            "description": "Number of nodes that are running the daemon pod, but are not supposed to run the daemon pod",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{node}"
         },
         "k8s.daemonset.ready_nodes": {
            "description": "Number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{node}"
         },
         "k8s.deployment.available": {
            "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.deployment.desired": {
            "description": "Number of desired pods in this deployment",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.hpa.current_replicas": {
            "description": "Current number of pod replicas managed by this autoscaler.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.hpa.desired_replicas": {
            "description": "Desired number of pod replicas managed by this autoscaler.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.hpa.max_replicas": {
            "description": "Maximum number of replicas to which the autoscaler can scale up.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.hpa.min_replicas": {
            "description": "Minimum number of replicas to which the autoscaler can scale up.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.job.active_pods": {
            "description": "The number of actively running pods for a job",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.job.desired_successful_pods": {
            "description": "The desired number of successfully finished pods the job should be run with",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.job.failed_pods": {
            "description": "The number of pods which reached phase Failed for a job",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.job.max_parallel_pods": {
            "description": "The max desired number of pods the job should run at any given time",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.job.successful_pods": {
            "description": "The number of pods which reached phase Succeeded for a job",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.namespace.phase": {
            "description": "The current phase of namespaces (1 for active and 0 for terminating)",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": ""
         },
         "k8s.node.condition": {
            "attributes": [
               "condition"
            ],
            "description": "The condition of a particular Node.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{condition}"
         },
         "k8s.pod.phase": {
            "description": "Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": ""
         },
         "k8s.pod.status_reason": {
            "description": "Current status reason of the pod (1 - Evicted, 2 - NodeAffinity, 3 - NodeLost, 4 - Shutdown, 5 - UnexpectedAdmissionError, 6 - Unknown)",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": ""
         },
         "k8s.replicaset.available": {
            "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replicaset",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.replicaset.desired": {
            "description": "Number of desired pods in this replicaset",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.replication_controller.available": {
            "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this replication_controller",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.replication_controller.desired": {
            "description": "Number of desired pods in this replication_controller",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.resource_quota.hard_limit": {
            "attributes": [
               "resource"
            ],
            "description": "The upper limit for a particular resource in a specific namespace. Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{resource}"
         },
         "k8s.resource_quota.used": {
            "attributes": [
               "resource"
            ],
            "description": "The usage for a particular resource in a specific namespace. Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{resource}"
         },
         "k8s.statefulset.current_pods": {
            "description": "The number of pods created by the StatefulSet controller from the StatefulSet version",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.statefulset.desired_pods": {
            "description": "Number of desired pods in the stateful set (the `spec.replicas` field)",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.statefulset.ready_pods": {
            "description": "Number of pods created by the stateful set that have the `Ready` condition",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "k8s.statefulset.updated_pods": {
            "description": "Number of pods created by the StatefulSet controller from the StatefulSet version",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{pod}"
         },
         "openshift.appliedclusterquota.limit": {
            "attributes": [
               "k8s.namespace.name",
               "resource"
            ],
            "description": "The upper limit for a particular resource in a specific namespace.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{resource}"
         },
         "openshift.appliedclusterquota.used": {
            "attributes": [
               "k8s.namespace.name",
               "resource"
            ],
            "description": "The usage for a particular resource in a specific namespace.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{resource}"
         },
         "openshift.clusterquota.limit": {
            "attributes": [
               "resource"
            ],
            "description": "The configured upper limit for a particular resource.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{resource}"
         },
         "openshift.clusterquota.used": {
            "attributes": [
               "resource"
            ],
            "description": "The usage for a particular resource with a configured limit.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{resource}"
         }
      },
      "resource_attributes": {
         "container.id": {
            "description": "The container id.",
            "enabled": true,
            "type": "string"
         },
         "container.image.name": {
            "description": "The container image name",
            "enabled": true,
            "type": "string"
         },
         "container.image.tag": {
            "description": "The container image tag",
            "enabled": true,
            "type": "string"
         },
         "k8s.container.name": {
            "description": "The k8s container name",
            "enabled": true,
            "type": "string"
         },
         "k8s.cronjob.name": {
            "description": "The k8s CronJob name",
            "enabled": true,
            "type": "string"
         },
         "k8s.cronjob.uid": {
            "description": "The k8s CronJob uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.daemonset.name": {
            "description": "The k8s daemonset name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.daemonset.uid": {
            "description": "The k8s daemonset uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.deployment.name": {
            "description": "The name of the Deployment.",
            "enabled": true,
            "type": "string"
         },
         "k8s.deployment.uid": {
            "description": "The UID of the Deployment.",
            "enabled": true,
            "type": "string"
         },
         "k8s.hpa.name": {
            "description": "The k8s hpa name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.hpa.uid": {
            "description": "The k8s hpa uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.job.name": {
            "description": "The k8s pod name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.job.uid": {
            "description": "The k8s job uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.kubelet.version": {
            "description": "The version of Kubelet running on the node.",
            "enabled": false,
            "type": "string"
         },
         "k8s.kubeproxy.version": {
            "description": "The version of Kube Proxy running on the node.",
            "enabled": false,
            "type": "string",
            "warnings": {
               "if_configured": "k8s.kubeproxy.version resource attribute is deprecated and will be removed soon."
            }
         },
         "k8s.namespace.name": {
            "description": "The k8s namespace name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.namespace.uid": {
            "description": "The k8s namespace uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.node.name": {
            "description": "The k8s node name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.node.uid": {
            "description": "The k8s node uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.name": {
            "description": "The k8s pod name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.qos_class": {
            "description": "The k8s pod qos class name. One of Guaranteed, Burstable, BestEffort.",
            "enabled": false,
            "type": "string"
         },
         "k8s.pod.uid": {
            "description": "The k8s pod uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.replicaset.name": {
            "description": "The k8s replicaset name",
            "enabled": true,
            "type": "string"
         },
         "k8s.replicaset.uid": {
            "description": "The k8s replicaset uid",
            "enabled": true,
            "type": "string"
         },
         "k8s.replicationcontroller.name": {
            "description": "The k8s replicationcontroller name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.replicationcontroller.uid": {
            "description": "The k8s replicationcontroller uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.resourcequota.name": {
            "description": "The k8s resourcequota name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.resourcequota.uid": {
            "description": "The k8s resourcequota uid.",
            "enabled": true,
            "type": "string"
         },
         "k8s.statefulset.name": {
            "description": "The k8s statefulset name.",
            "enabled": true,
            "type": "string"
         },
         "k8s.statefulset.uid": {
            "description": "The k8s statefulset uid.",
            "enabled": true,
            "type": "string"
         },
         "openshift.clusterquota.name": {
            "description": "The k8s ClusterResourceQuota name.",
            "enabled": true,
            "type": "string"
         },
         "openshift.clusterquota.uid": {
            "description": "The k8s ClusterResourceQuota uid.",
            "enabled": true,
            "type": "string"
         }
      },
      "sem_conv_version": "1.18.0",
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "TylerHelmuth",
               "povilasv"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "metrics"
            ],
            "development": [
               "logs"
            ]
         }
      },
      "type": "k8s_cluster"
   },
   "k8seventsreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "TylerHelmuth"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "k8s_events"
   },
   "k8snode": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "k8s.node.name": {
            "description": "The Kubernetes node name",
            "enabled": true,
            "type": "string"
         },
         "k8s.node.uid": {
            "description": "The Kubernetes node UID",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/k8snode"
   },
   "k8sobjectsreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "hvaghani221",
               "TylerHelmuth"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "type": "k8sobjects"
   },
   "kafkaexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "pavolloffay",
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "aws"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "kafka"
   },
   "kafkametricsreceiver": {
      "attributes": {
         "group": {
            "description": "The ID (string) of a consumer group",
            "type": "string"
         },
         "partition": {
            "description": "The number (integer) of the partition",
            "type": "int"
         },
         "topic": {
            "description": "The ID (integer) of a topic",
            "type": "string"
         }
      },
      "metrics": {
         "kafka.brokers": {
            "description": "Number of brokers in the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{brokers}"
         },
         "kafka.consumer_group.lag": {
            "attributes": [
               "group",
               "topic",
               "partition"
            ],
            "description": "Current approximate lag of consumer group at partition of topic",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "kafka.consumer_group.lag_sum": {
            "attributes": [
               "group",
               "topic"
            ],
            "description": "Current approximate sum of consumer group lag across all partitions of topic",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "kafka.consumer_group.members": {
            "attributes": [
               "group"
            ],
            "description": "Count of members in the consumer group",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{members}"
         },
         "kafka.consumer_group.offset": {
            "attributes": [
               "group",
               "topic",
               "partition"
            ],
            "description": "Current offset of the consumer group at partition of topic",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "kafka.consumer_group.offset_sum": {
            "attributes": [
               "group",
               "topic"
            ],
            "description": "Sum of consumer group offset across partitions of topic",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "kafka.partition.current_offset": {
            "attributes": [
               "topic",
               "partition"
            ],
            "description": "Current offset of partition of topic.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "kafka.partition.oldest_offset": {
            "attributes": [
               "topic",
               "partition"
            ],
            "description": "Oldest offset of partition of topic",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "kafka.partition.replicas": {
            "attributes": [
               "topic",
               "partition"
            ],
            "description": "Number of replicas for partition of topic",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{replicas}"
         },
         "kafka.partition.replicas_in_sync": {
            "attributes": [
               "topic",
               "partition"
            ],
            "description": "Number of synchronized replicas of partition",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{replicas}"
         },
         "kafka.topic.partitions": {
            "attributes": [
               "topic"
            ],
            "description": "Number of partitions in topic.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{partitions}"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "kafkametrics"
   },
   "kafkareceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "pavolloffay",
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics",
               "logs",
               "traces"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "kafka"
   },
   "kineticaexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "am-kinetica",
               "TylerHelmuth"
            ]
         },
         "distributions": [ ],
         "stability": {
            "development": [
               "metrics",
               "traces",
               "logs"
            ]
         }
      },
      "type": "kinetica"
   },
   "kubeletstatsreceiver": {
      "attributes": {
         "direction": {
            "description": "Direction of flow of bytes/operations (receive or transmit).",
            "enum": [
               "receive",
               "transmit"
            ],
            "type": "string"
         },
         "interface": {
            "description": "Name of the network interface.",
            "type": "string"
         }
      },
      "metrics": {
         "container.cpu.time": {
            "attributes": [ ],
            "description": "Container CPU time",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "container.cpu.utilization": {
            "attributes": [ ],
            "description": "Container CPU utilization",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "container.filesystem.available": {
            "attributes": [ ],
            "description": "Container filesystem available",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.filesystem.capacity": {
            "attributes": [ ],
            "description": "Container filesystem capacity",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.filesystem.usage": {
            "attributes": [ ],
            "description": "Container filesystem usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.available": {
            "attributes": [ ],
            "description": "Container memory available",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.major_page_faults": {
            "attributes": [ ],
            "description": "Container memory major_page_faults",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "container.memory.page_faults": {
            "attributes": [ ],
            "description": "Container memory page_faults",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "container.memory.rss": {
            "attributes": [ ],
            "description": "Container memory rss",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.usage": {
            "attributes": [ ],
            "description": "Container memory usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.memory.working_set": {
            "attributes": [ ],
            "description": "Container memory working_set",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "container.uptime": {
            "attributes": [ ],
            "description": "The time since the container started",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         },
         "k8s.container.cpu_limit_utilization": {
            "attributes": [ ],
            "description": "Container cpu utilization as a ratio of the container's limits",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.container.cpu_request_utilization": {
            "attributes": [ ],
            "description": "Container cpu utilization as a ratio of the container's requests",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.container.memory_limit_utilization": {
            "attributes": [ ],
            "description": "Container memory utilization as a ratio of the container's limits",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.container.memory_request_utilization": {
            "attributes": [ ],
            "description": "Container memory utilization as a ratio of the container's requests",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.node.cpu.time": {
            "attributes": [ ],
            "description": "Node CPU time",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "k8s.node.cpu.utilization": {
            "attributes": [ ],
            "description": "Node CPU utilization",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.node.filesystem.available": {
            "attributes": [ ],
            "description": "Node filesystem available",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.filesystem.capacity": {
            "attributes": [ ],
            "description": "Node filesystem capacity",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.filesystem.usage": {
            "attributes": [ ],
            "description": "Node filesystem usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.memory.available": {
            "attributes": [ ],
            "description": "Node memory available",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.memory.major_page_faults": {
            "attributes": [ ],
            "description": "Node memory major_page_faults",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.node.memory.page_faults": {
            "attributes": [ ],
            "description": "Node memory page_faults",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.node.memory.rss": {
            "attributes": [ ],
            "description": "Node memory rss",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.memory.usage": {
            "attributes": [ ],
            "description": "Node memory usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.memory.working_set": {
            "attributes": [ ],
            "description": "Node memory working_set",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.network.errors": {
            "attributes": [
               "interface",
               "direction"
            ],
            "description": "Node network errors",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.node.network.io": {
            "attributes": [
               "interface",
               "direction"
            ],
            "description": "Node network IO",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.node.uptime": {
            "attributes": [ ],
            "description": "The time since the node started",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         },
         "k8s.pod.cpu.time": {
            "attributes": [ ],
            "description": "Pod CPU time",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "k8s.pod.cpu.utilization": {
            "attributes": [ ],
            "description": "Pod CPU utilization",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.pod.cpu_limit_utilization": {
            "attributes": [ ],
            "description": "Pod cpu utilization as a ratio of the pod's total container limits. If any container is missing a limit the metric is not emitted.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.pod.cpu_request_utilization": {
            "attributes": [ ],
            "description": "Pod cpu utilization as a ratio of the pod's total container requests. If any container is missing a request the metric is not emitted.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.pod.filesystem.available": {
            "attributes": [ ],
            "description": "Pod filesystem available",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.filesystem.capacity": {
            "attributes": [ ],
            "description": "Pod filesystem capacity",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.filesystem.usage": {
            "attributes": [ ],
            "description": "Pod filesystem usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.memory.available": {
            "attributes": [ ],
            "description": "Pod memory available",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.memory.major_page_faults": {
            "attributes": [ ],
            "description": "Pod memory major_page_faults",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.pod.memory.page_faults": {
            "attributes": [ ],
            "description": "Pod memory page_faults",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.pod.memory.rss": {
            "attributes": [ ],
            "description": "Pod memory rss",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.memory.usage": {
            "attributes": [ ],
            "description": "Pod memory usage",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.memory.working_set": {
            "attributes": [ ],
            "description": "Pod memory working_set",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.memory_limit_utilization": {
            "attributes": [ ],
            "description": "Pod memory utilization as a ratio of the pod's total container limits. If any container is missing a limit the metric is not emitted.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.pod.memory_request_utilization": {
            "attributes": [ ],
            "description": "Pod memory utilization as a ratio of the pod's total container requests. If any container is missing a request the metric is not emitted.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "k8s.pod.network.errors": {
            "attributes": [
               "interface",
               "direction"
            ],
            "description": "Pod network errors",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.pod.network.io": {
            "attributes": [
               "interface",
               "direction"
            ],
            "description": "Pod network IO",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.pod.uptime": {
            "attributes": [ ],
            "description": "The time since the pod started",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         },
         "k8s.volume.available": {
            "attributes": [ ],
            "description": "The number of available bytes in the volume.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.volume.capacity": {
            "attributes": [ ],
            "description": "The total capacity in bytes of the volume.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "k8s.volume.inodes": {
            "attributes": [ ],
            "description": "The total inodes in the filesystem.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.volume.inodes.free": {
            "attributes": [ ],
            "description": "The free inodes in the filesystem.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "k8s.volume.inodes.used": {
            "attributes": [ ],
            "description": "The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         }
      },
      "resource_attributes": {
         "aws.volume.id": {
            "description": "The id of the AWS Volume",
            "enabled": true,
            "type": "string"
         },
         "container.id": {
            "description": "Container id used to identify container",
            "enabled": true,
            "type": "string"
         },
         "fs.type": {
            "description": "The filesystem type of the Volume",
            "enabled": true,
            "type": "string"
         },
         "gce.pd.name": {
            "description": "The name of the persistent disk in GCE",
            "enabled": true,
            "type": "string"
         },
         "glusterfs.endpoints.name": {
            "description": "The endpoint name that details Glusterfs topology",
            "enabled": true,
            "type": "string"
         },
         "glusterfs.path": {
            "description": "Glusterfs volume path",
            "enabled": true,
            "type": "string"
         },
         "k8s.container.name": {
            "description": "Container name used by container runtime",
            "enabled": true,
            "type": "string"
         },
         "k8s.namespace.name": {
            "description": "The name of the namespace that the pod is running in",
            "enabled": true,
            "type": "string"
         },
         "k8s.node.name": {
            "description": "The name of the Node",
            "enabled": true,
            "type": "string"
         },
         "k8s.persistentvolumeclaim.name": {
            "description": "The name of the Persistent Volume Claim",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.name": {
            "description": "The name of the Pod",
            "enabled": true,
            "type": "string"
         },
         "k8s.pod.uid": {
            "description": "The UID of the Pod",
            "enabled": true,
            "type": "string"
         },
         "k8s.volume.name": {
            "description": "The name of the Volume",
            "enabled": true,
            "type": "string"
         },
         "k8s.volume.type": {
            "description": "The type of the Volume",
            "enabled": true,
            "type": "string"
         },
         "partition": {
            "description": "The partition in the Volume",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "TylerHelmuth"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "kubeletstats"
   },
   "lambda": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "aws.log.group.names": {
            "description": "The aws.log.group.names",
            "enabled": true,
            "type": "slice"
         },
         "aws.log.stream.names": {
            "description": "The aws.log.stream.names",
            "enabled": true,
            "type": "slice"
         },
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud.region",
            "enabled": true,
            "type": "string"
         },
         "faas.instance": {
            "description": "The faas.instance",
            "enabled": true,
            "type": "string"
         },
         "faas.max_memory": {
            "description": "The faas.max_memory",
            "enabled": true,
            "type": "string"
         },
         "faas.name": {
            "description": "faas.name",
            "enabled": true,
            "type": "string"
         },
         "faas.version": {
            "description": "The faas.version",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/lambda"
   },
   "loadbalancingexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "jpkrohling"
            ]
         },
         "distributions": [
            "contrib",
            "grafana",
            "observiq",
            "sumo",
            "aws",
            "splunk"
         ],
         "stability": {
            "beta": [
               "traces",
               "logs"
            ],
            "development": [
               "metrics"
            ]
         }
      },
      "type": "loadbalancing"
   },
   "loadscraper": {
      "metrics": {
         "system.cpu.load_average.15m": {
            "description": "Average CPU Load over 15 minutes.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{thread}"
         },
         "system.cpu.load_average.1m": {
            "description": "Average CPU Load over 1 minute.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{thread}"
         },
         "system.cpu.load_average.5m": {
            "description": "Average CPU Load over 5 minutes.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{thread}"
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/load"
   },
   "loggingexporter": {
      "status": {
         "class": "exporter",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "deprecated": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "logging"
   },
   "logicmonitorexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "bogdandrutu",
               "khyatigandhi6",
               "avadhut123pisal"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "traces",
               "logs"
            ]
         }
      },
      "type": "logicmonitor"
   },
   "logstransformprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "djaglowski",
               "dehaansa"
            ]
         },
         "distributions": [
            "observiq",
            "splunk",
            "sumo"
         ],
         "stability": {
            "development": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "operators": [
               {
                  "regex": "^(?P<time>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) (?P<sev>[A-Z]*) (?P<msg>.*)$",
                  "type": "regex_parser"
               }
            ]
         }
      },
      "type": "logstransform"
   },
   "logzioexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "yotamloe"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "aws"
         ],
         "stability": {
            "beta": [
               "traces",
               "logs"
            ]
         }
      },
      "type": "logzio"
   },
   "lokiexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "gramidt",
               "gouthamve",
               "jpkrohling",
               "mar4uk"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "type": "loki"
   },
   "lokireceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "mar4uk",
               "jpkrohling"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "loki"
   },
   "memcachedreceiver": {
      "attributes": {
         "command": {
            "description": "The type of command.",
            "enum": [
               "get",
               "set",
               "flush",
               "touch"
            ],
            "type": "string"
         },
         "direction": {
            "description": "Direction of data flow.",
            "enum": [
               "sent",
               "received"
            ],
            "type": "string"
         },
         "operation": {
            "description": "The type of operation.",
            "enum": [
               "increment",
               "decrement",
               "get"
            ],
            "type": "string"
         },
         "state": {
            "description": "The type of CPU usage.",
            "enum": [
               "system",
               "user"
            ],
            "type": "string"
         },
         "type": {
            "description": "Result of cache request.",
            "enum": [
               "hit",
               "miss"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "memcached.bytes": {
            "attributes": [ ],
            "description": "Current number of bytes used by this server to store items.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "memcached.commands": {
            "attributes": [
               "command"
            ],
            "description": "Commands executed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{commands}"
         },
         "memcached.connections.current": {
            "attributes": [ ],
            "description": "The current number of open connections.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "memcached.connections.total": {
            "attributes": [ ],
            "description": "Total number of connections opened since the server started running.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "memcached.cpu.usage": {
            "attributes": [
               "state"
            ],
            "description": "Accumulated user and system time.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "memcached.current_items": {
            "attributes": [ ],
            "description": "Number of items currently stored in the cache.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{items}"
         },
         "memcached.evictions": {
            "attributes": [ ],
            "description": "Cache item evictions.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{evictions}"
         },
         "memcached.network": {
            "attributes": [
               "direction"
            ],
            "description": "Bytes transferred over the network.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "by"
         },
         "memcached.operation_hit_ratio": {
            "attributes": [
               "operation"
            ],
            "description": "Hit ratio for operations, expressed as a percentage value between 0.0 and 100.0.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "memcached.operations": {
            "attributes": [
               "type",
               "operation"
            ],
            "description": "Operation counts.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "memcached.threads": {
            "attributes": [ ],
            "description": "Number of threads used by the memcached instance.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "memcached"
   },
   "memorylimiterprocessor": {
      "status": {
         "class": "processor",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "memory_limiter"
   },
   "memoryscraper": {
      "attributes": {
         "state": {
            "description": "Breakdown of memory usage by type.",
            "enum": [
               "buffered",
               "cached",
               "inactive",
               "free",
               "slab_reclaimable",
               "slab_unreclaimable",
               "used"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "system.linux.memory.available": {
            "description": "An estimate of how much memory is available for starting new applications, without swapping. This is a more accurate alternative than system.memory.usage with state=free. (Linux only)",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.memory.limit": {
            "description": "Total bytes of memory available.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.memory.usage": {
            "attributes": [
               "state"
            ],
            "description": "Bytes of memory in use.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.memory.utilization": {
            "attributes": [
               "state"
            ],
            "description": "Percentage of memory bytes in use.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/memory"
   },
   "metricsgenerationprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "Aneurysm9"
            ]
         },
         "distributions": [
            "contrib",
            "sumo",
            "aws"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "experimental_metricsgeneration"
   },
   "metricstransformprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "dmitryax"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "aws"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "metricstransform"
   },
   "mezmoexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "dashpole",
               "billmeyer",
               "gjanco"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "type": "mezmo"
   },
   "mongodbatlasreceiver": {
      "attributes": {
         "assert_type": {
            "description": "MongoDB assertion type",
            "enum": [
               "regular",
               "warning",
               "msg",
               "user"
            ],
            "type": "string"
         },
         "btree_counter_type": {
            "description": "Database index effectiveness",
            "enum": [
               "accesses",
               "hits",
               "misses"
            ],
            "type": "string"
         },
         "cache_direction": {
            "description": "Whether read into or written from",
            "enum": [
               "read_into",
               "written_from"
            ],
            "type": "string"
         },
         "cache_status": {
            "description": "Cache status",
            "enum": [
               "dirty",
               "used"
            ],
            "type": "string"
         },
         "cluster_role": {
            "description": "Whether process is acting as replica or primary",
            "enum": [
               "primary",
               "replica"
            ],
            "type": "string"
         },
         "cpu_state": {
            "description": "CPU state",
            "enum": [
               "kernel",
               "user",
               "nice",
               "iowait",
               "irq",
               "softirq",
               "guest",
               "steal"
            ],
            "type": "string"
         },
         "cursor_state": {
            "description": "Whether cursor is open or timed out",
            "enum": [
               "timed_out",
               "open"
            ],
            "type": "string"
         },
         "direction": {
            "description": "Network traffic direction",
            "enum": [
               "receive",
               "transmit"
            ],
            "type": "string"
         },
         "disk_direction": {
            "description": "Measurement type for disk operation",
            "enum": [
               "read",
               "write",
               "total"
            ],
            "type": "string"
         },
         "disk_status": {
            "description": "Disk measurement type",
            "enum": [
               "free",
               "used"
            ],
            "type": "string"
         },
         "document_status": {
            "description": "Status of documents in the database",
            "enum": [
               "returned",
               "inserted",
               "updated",
               "deleted"
            ],
            "type": "string"
         },
         "execution_type": {
            "description": "Type of command",
            "enum": [
               "reads",
               "writes",
               "commands"
            ],
            "type": "string"
         },
         "global_lock_state": {
            "description": "Which queue is locked",
            "enum": [
               "current_queue_total",
               "current_queue_readers",
               "current_queue_writers"
            ],
            "type": "string"
         },
         "memory_issue_type": {
            "description": "Type of memory issue encountered",
            "enum": [
               "extra_info",
               "global_accesses_not_in_memory",
               "exceptions_thrown"
            ],
            "type": "string"
         },
         "memory_state": {
            "description": "Memory usage type",
            "enum": [
               "resident",
               "virtual",
               "mapped",
               "computed",
               "shared",
               "free",
               "used"
            ],
            "type": "string"
         },
         "memory_status": {
            "description": "Memory measurement type",
            "enum": [
               "available",
               "buffers",
               "cached",
               "free",
               "shared",
               "used"
            ],
            "type": "string"
         },
         "object_type": {
            "description": "MongoDB object type",
            "enum": [
               "collection",
               "index",
               "extent",
               "object",
               "view",
               "storage",
               "data"
            ],
            "type": "string"
         },
         "operation": {
            "description": "Type of database operation",
            "enum": [
               "cmd",
               "query",
               "update",
               "delete",
               "getmore",
               "insert",
               "scan_and_order"
            ],
            "type": "string"
         },
         "oplog_type": {
            "description": "Oplog type",
            "enum": [
               "slave_lag_master_time",
               "master_time",
               "master_lag_time_diff"
            ],
            "type": "string"
         },
         "scanned_type": {
            "description": "Objects or indexes scanned during query",
            "enum": [
               "index_items",
               "objects"
            ],
            "type": "string"
         },
         "storage_status": {
            "description": "Views on database size",
            "enum": [
               "total",
               "data_size",
               "index_size",
               "data_size_wo_system"
            ],
            "type": "string"
         },
         "ticket_type": {
            "description": "Type of ticket available",
            "enum": [
               "available_reads",
               "available_writes"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "mongodbatlas.db.counts": {
            "attributes": [
               "object_type"
            ],
            "description": "Database feature size",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DATABASE_EXTENT_COUNT, DATABASE_VIEW_COUNT, DATABASE_COLLECTION_COUNT, DATABASE_OBJECT_COUNT, DATABASE_INDEX_COUNT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{objects}"
         },
         "mongodbatlas.db.size": {
            "attributes": [
               "object_type"
            ],
            "description": "Database feature size",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DATABASE_DATA_SIZE, DATABASE_STORAGE_SIZE, DATABASE_INDEX_SIZE, DATABASE_AVERAGE_OBJECT_SIZE",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.disk.partition.iops.average": {
            "attributes": [
               "disk_direction"
            ],
            "description": "Disk partition iops",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DISK_PARTITION_IOPS_READ, DISK_PARTITION_IOPS_WRITE, DISK_PARTITION_IOPS_TOTAL",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{ops}/s"
         },
         "mongodbatlas.disk.partition.iops.max": {
            "attributes": [
               "disk_direction"
            ],
            "description": "Disk partition iops",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_DISK_PARTITION_IOPS_WRITE, MAX_DISK_PARTITION_IOPS_TOTAL, MAX_DISK_PARTITION_IOPS_READ",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{ops}/s"
         },
         "mongodbatlas.disk.partition.latency.average": {
            "attributes": [
               "disk_direction"
            ],
            "description": "Disk partition latency",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DISK_PARTITION_LATENCY_WRITE, DISK_PARTITION_LATENCY_READ",
            "gauge": {
               "value_type": "double"
            },
            "unit": "ms"
         },
         "mongodbatlas.disk.partition.latency.max": {
            "attributes": [
               "disk_direction"
            ],
            "description": "Disk partition latency",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_DISK_PARTITION_LATENCY_WRITE, MAX_DISK_PARTITION_LATENCY_READ",
            "gauge": {
               "value_type": "double"
            },
            "unit": "ms"
         },
         "mongodbatlas.disk.partition.space.average": {
            "attributes": [
               "disk_status"
            ],
            "description": "Disk partition space",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DISK_PARTITION_SPACE_FREE, DISK_PARTITION_SPACE_USED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.disk.partition.space.max": {
            "attributes": [
               "disk_status"
            ],
            "description": "Disk partition space",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DISK_PARTITION_SPACE_FREE, DISK_PARTITION_SPACE_USED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.disk.partition.usage.average": {
            "attributes": [
               "disk_status"
            ],
            "description": "Disk partition usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DISK_PARTITION_SPACE_PERCENT_FREE, DISK_PARTITION_SPACE_PERCENT_USED",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.disk.partition.usage.max": {
            "attributes": [
               "disk_status"
            ],
            "description": "Disk partition usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_DISK_PARTITION_SPACE_PERCENT_USED, MAX_DISK_PARTITION_SPACE_PERCENT_FREE",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.disk.partition.utilization.average": {
            "description": "The percentage of time during which requests are being issued to and serviced by the partition.",
            "enabled": true,
            "extended_documentation": "MongoDB Metrics DISK_PARTITION_UTILIZATION",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.disk.partition.utilization.max": {
            "description": "The maximum percentage of time during which requests are being issued to and serviced by the partition.",
            "enabled": true,
            "extended_documentation": "MongoDB Metrics MAX_DISK_PARTITION_UTILIZATION",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.asserts": {
            "attributes": [
               "assert_type"
            ],
            "description": "Number of assertions per second",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics ASSERT_REGULAR, ASSERT_USER, ASSERT_MSG, ASSERT_WARNING",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{assertions}/s"
         },
         "mongodbatlas.process.background_flush": {
            "description": "Amount of data flushed in the background",
            "enabled": true,
            "extended_documentation": "MongoDB Metric BACKGROUND_FLUSH_AVG",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cache.io": {
            "attributes": [
               "cache_direction"
            ],
            "description": "Cache throughput (per second)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics CACHE_BYTES_READ_INTO, CACHE_BYTES_WRITTEN_FROM",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.process.cache.size": {
            "attributes": [
               "cache_status"
            ],
            "description": "Cache sizes",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics CACHE_USED_BYTES, CACHE_DIRTY_BYTES",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.process.connections": {
            "description": "Number of current connections",
            "enabled": true,
            "extended_documentation": "MongoDB Metric CONNECTIONS",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "double"
            },
            "unit": "{connections}"
         },
         "mongodbatlas.process.cpu.children.normalized.usage.average": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage for child processes, normalized to pct",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics PROCESS_NORMALIZED_CPU_CHILDREN_KERNEL, PROCESS_NORMALIZED_CPU_CHILDREN_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.children.normalized.usage.max": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage for child processes, normalized to pct",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_PROCESS_NORMALIZED_CPU_CHILDREN_KERNEL, MAX_PROCESS_NORMALIZED_CPU_CHILDREN_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.children.usage.average": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage for child processes (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics PROCESS_CPU_CHILDREN_KERNEL, PROCESS_CPU_CHILDREN_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.children.usage.max": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage for child processes (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_PROCESS_CPU_CHILDREN_USER, MAX_PROCESS_CPU_CHILDREN_KERNEL",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.normalized.usage.average": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage, normalized to pct",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics PROCESS_NORMALIZED_CPU_KERNEL, PROCESS_NORMALIZED_CPU_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.normalized.usage.max": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage, normalized to pct",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_PROCESS_NORMALIZED_CPU_USER, MAX_PROCESS_NORMALIZED_CPU_KERNEL",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.usage.average": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics PROCESS_CPU_KERNEL, PROCESS_CPU_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cpu.usage.max": {
            "attributes": [
               "cpu_state"
            ],
            "description": "CPU Usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_PROCESS_CPU_KERNEL, MAX_PROCESS_CPU_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.cursors": {
            "attributes": [
               "cursor_state"
            ],
            "description": "Number of cursors",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics CURSORS_TOTAL_OPEN, CURSORS_TOTAL_TIMED_OUT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{cursors}"
         },
         "mongodbatlas.process.db.document.rate": {
            "attributes": [
               "document_status"
            ],
            "description": "Document access rates",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DOCUMENT_METRICS_UPDATED, DOCUMENT_METRICS_DELETED, DOCUMENT_METRICS_RETURNED, DOCUMENT_METRICS_INSERTED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{documents}/s"
         },
         "mongodbatlas.process.db.operations.rate": {
            "attributes": [
               "operation",
               "cluster_role"
            ],
            "description": "DB Operation Rates",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics OPCOUNTER_GETMORE, OPERATIONS_SCAN_AND_ORDER, OPCOUNTER_UPDATE, OPCOUNTER_REPL_UPDATE, OPCOUNTER_CMD, OPCOUNTER_DELETE, OPCOUNTER_REPL_DELETE, OPCOUNTER_REPL_CMD, OPCOUNTER_QUERY, OPCOUNTER_REPL_INSERT, OPCOUNTER_INSERT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{operations}/s"
         },
         "mongodbatlas.process.db.operations.time": {
            "attributes": [
               "execution_type"
            ],
            "description": "DB Operation Times",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics OP_EXECUTION_TIME_WRITES, OP_EXECUTION_TIME_COMMANDS, OP_EXECUTION_TIME_READS",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "ms"
         },
         "mongodbatlas.process.db.query_executor.scanned": {
            "attributes": [
               "scanned_type"
            ],
            "description": "Scanned objects",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics QUERY_EXECUTOR_SCANNED_OBJECTS, QUERY_EXECUTOR_SCANNED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{objects}/s"
         },
         "mongodbatlas.process.db.query_targeting.scanned_per_returned": {
            "attributes": [
               "scanned_type"
            ],
            "description": "Scanned objects per returned",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics QUERY_TARGETING_SCANNED_OBJECTS_PER_RETURNED, QUERY_TARGETING_SCANNED_PER_RETURNED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{scanned}/{returned}"
         },
         "mongodbatlas.process.db.storage": {
            "attributes": [
               "storage_status"
            ],
            "description": "Storage used by the database",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics DB_INDEX_SIZE_TOTAL, DB_DATA_SIZE_TOTAL_WO_SYSTEM, DB_STORAGE_TOTAL, DB_DATA_SIZE_TOTAL",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.process.global_lock": {
            "attributes": [
               "global_lock_state"
            ],
            "description": "Number and status of locks",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics GLOBAL_LOCK_CURRENT_QUEUE_WRITERS, GLOBAL_LOCK_CURRENT_QUEUE_READERS, GLOBAL_LOCK_CURRENT_QUEUE_TOTAL",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{locks}"
         },
         "mongodbatlas.process.index.btree_miss_ratio": {
            "description": "Index miss ratio (%)",
            "enabled": true,
            "extended_documentation": "MongoDB Metric INDEX_COUNTERS_BTREE_MISS_RATIO",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.process.index.counters": {
            "attributes": [
               "btree_counter_type"
            ],
            "description": "Indexes",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics INDEX_COUNTERS_BTREE_MISSES, INDEX_COUNTERS_BTREE_ACCESSES, INDEX_COUNTERS_BTREE_HITS",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{indexes}"
         },
         "mongodbatlas.process.journaling.commits": {
            "description": "Journaling commits",
            "enabled": true,
            "extended_documentation": "MongoDB Metric JOURNALING_COMMITS_IN_WRITE_LOCK",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{commits}"
         },
         "mongodbatlas.process.journaling.data_files": {
            "description": "Data file sizes",
            "enabled": true,
            "extended_documentation": "MongoDB Metric JOURNALING_WRITE_DATA_FILES_MB",
            "gauge": {
               "value_type": "double"
            },
            "unit": "MiBy"
         },
         "mongodbatlas.process.journaling.written": {
            "description": "Journals written",
            "enabled": true,
            "extended_documentation": "MongoDB Metric JOURNALING_MB",
            "gauge": {
               "value_type": "double"
            },
            "unit": "MiBy"
         },
         "mongodbatlas.process.memory.usage": {
            "attributes": [
               "memory_state"
            ],
            "description": "Memory Usage",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MEMORY_MAPPED, MEMORY_VIRTUAL, COMPUTED_MEMORY, MEMORY_RESIDENT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.process.network.io": {
            "attributes": [
               "direction"
            ],
            "description": "Network IO",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics NETWORK_BYTES_OUT, NETWORK_BYTES_IN",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By/s"
         },
         "mongodbatlas.process.network.requests": {
            "description": "Network requests",
            "enabled": true,
            "extended_documentation": "MongoDB Metric NETWORK_NUM_REQUESTS",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "{requests}"
         },
         "mongodbatlas.process.oplog.rate": {
            "description": "Execution rate by operation",
            "enabled": true,
            "extended_documentation": "MongoDB Metric OPLOG_RATE_GB_PER_HOUR",
            "gauge": {
               "value_type": "double"
            },
            "unit": "GiBy/h"
         },
         "mongodbatlas.process.oplog.time": {
            "attributes": [
               "oplog_type"
            ],
            "description": "Execution time by operation",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics OPLOG_MASTER_TIME, OPLOG_SLAVE_LAG_MASTER_TIME, OPLOG_MASTER_LAG_TIME_DIFF",
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "mongodbatlas.process.page_faults": {
            "attributes": [
               "memory_issue_type"
            ],
            "description": "Page faults",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics GLOBAL_PAGE_FAULT_EXCEPTIONS_THROWN, EXTRA_INFO_PAGE_FAULTS, GLOBAL_ACCESSES_NOT_IN_MEMORY",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{faults}/s"
         },
         "mongodbatlas.process.restarts": {
            "description": "Restarts in last hour",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics RESTARTS_IN_LAST_HOUR",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{restarts}/h"
         },
         "mongodbatlas.process.tickets": {
            "attributes": [
               "ticket_type"
            ],
            "description": "Tickets",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics TICKETS_AVAILABLE_WRITE, TICKETS_AVAILABLE_READS",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{tickets}"
         },
         "mongodbatlas.system.cpu.normalized.usage.average": {
            "attributes": [
               "cpu_state"
            ],
            "description": "System CPU Normalized to pct",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics SYSTEM_NORMALIZED_CPU_IOWAIT, SYSTEM_NORMALIZED_CPU_GUEST, SYSTEM_NORMALIZED_CPU_IRQ, SYSTEM_NORMALIZED_CPU_KERNEL, SYSTEM_NORMALIZED_CPU_STEAL, SYSTEM_NORMALIZED_CPU_SOFTIRQ, SYSTEM_NORMALIZED_CPU_NICE, SYSTEM_NORMALIZED_CPU_USER",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.system.cpu.normalized.usage.max": {
            "attributes": [
               "cpu_state"
            ],
            "description": "System CPU Normalized to pct",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_SYSTEM_NORMALIZED_CPU_USER, MAX_SYSTEM_NORMALIZED_CPU_NICE, MAX_SYSTEM_NORMALIZED_CPU_IOWAIT, MAX_SYSTEM_NORMALIZED_CPU_SOFTIRQ, MAX_SYSTEM_NORMALIZED_CPU_STEAL, MAX_SYSTEM_NORMALIZED_CPU_KERNEL, MAX_SYSTEM_NORMALIZED_CPU_GUEST, MAX_SYSTEM_NORMALIZED_CPU_IRQ",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.system.cpu.usage.average": {
            "attributes": [
               "cpu_state"
            ],
            "description": "System CPU Usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics SYSTEM_CPU_USER, SYSTEM_CPU_GUEST, SYSTEM_CPU_SOFTIRQ, SYSTEM_CPU_IRQ, SYSTEM_CPU_KERNEL, SYSTEM_CPU_IOWAIT, SYSTEM_CPU_NICE, SYSTEM_CPU_STEAL",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.system.cpu.usage.max": {
            "attributes": [
               "cpu_state"
            ],
            "description": "System CPU Usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_SYSTEM_CPU_SOFTIRQ, MAX_SYSTEM_CPU_IRQ, MAX_SYSTEM_CPU_GUEST, MAX_SYSTEM_CPU_IOWAIT, MAX_SYSTEM_CPU_NICE, MAX_SYSTEM_CPU_KERNEL, MAX_SYSTEM_CPU_USER, MAX_SYSTEM_CPU_STEAL",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.system.fts.cpu.normalized.usage": {
            "attributes": [
               "cpu_state"
            ],
            "description": "Full text search disk usage (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics FTS_PROCESS_NORMALIZED_CPU_USER, FTS_PROCESS_NORMALIZED_CPU_KERNEL",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.system.fts.cpu.usage": {
            "attributes": [
               "cpu_state"
            ],
            "description": "Full-text search (%)",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics FTS_PROCESS_CPU_USER, FTS_PROCESS_CPU_KERNEL",
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "mongodbatlas.system.fts.disk.used": {
            "description": "Full text search disk usage",
            "enabled": true,
            "extended_documentation": "MongoDB Metric FTS_DISK_USAGE",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "mongodbatlas.system.fts.memory.usage": {
            "attributes": [
               "memory_state"
            ],
            "description": "Full-text search",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics FTS_MEMORY_MAPPED, FTS_PROCESS_SHARED_MEMORY, FTS_PROCESS_RESIDENT_MEMORY, FTS_PROCESS_VIRTUAL_MEMORY",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "MiBy"
         },
         "mongodbatlas.system.memory.usage.average": {
            "attributes": [
               "memory_status"
            ],
            "description": "System Memory Usage",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics SYSTEM_MEMORY_AVAILABLE, SYSTEM_MEMORY_BUFFERS, SYSTEM_MEMORY_USED, SYSTEM_MEMORY_CACHED, SYSTEM_MEMORY_SHARED, SYSTEM_MEMORY_FREE",
            "gauge": {
               "value_type": "double"
            },
            "unit": "KiBy"
         },
         "mongodbatlas.system.memory.usage.max": {
            "attributes": [
               "memory_status"
            ],
            "description": "System Memory Usage",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_SYSTEM_MEMORY_CACHED, MAX_SYSTEM_MEMORY_AVAILABLE, MAX_SYSTEM_MEMORY_USED, MAX_SYSTEM_MEMORY_BUFFERS, MAX_SYSTEM_MEMORY_FREE, MAX_SYSTEM_MEMORY_SHARED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "KiBy"
         },
         "mongodbatlas.system.network.io.average": {
            "attributes": [
               "direction"
            ],
            "description": "System Network IO",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics SYSTEM_NETWORK_IN, SYSTEM_NETWORK_OUT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By/s"
         },
         "mongodbatlas.system.network.io.max": {
            "attributes": [
               "direction"
            ],
            "description": "System Network IO",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_SYSTEM_NETWORK_OUT, MAX_SYSTEM_NETWORK_IN",
            "gauge": {
               "value_type": "double"
            },
            "unit": "By/s"
         },
         "mongodbatlas.system.paging.io.average": {
            "attributes": [
               "direction"
            ],
            "description": "Swap IO",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics SWAP_IO_IN, SWAP_IO_OUT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{pages}/s"
         },
         "mongodbatlas.system.paging.io.max": {
            "attributes": [
               "direction"
            ],
            "description": "Swap IO",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_SWAP_IO_IN, MAX_SWAP_IO_OUT",
            "gauge": {
               "value_type": "double"
            },
            "unit": "{pages}/s"
         },
         "mongodbatlas.system.paging.usage.average": {
            "attributes": [
               "memory_state"
            ],
            "description": "Swap usage",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics SWAP_USAGE_FREE, SWAP_USAGE_USED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "KiBy"
         },
         "mongodbatlas.system.paging.usage.max": {
            "attributes": [
               "memory_state"
            ],
            "description": "Swap usage",
            "enabled": true,
            "extended_documentation": "Aggregate of MongoDB Metrics MAX_SWAP_USAGE_FREE, MAX_SWAP_USAGE_USED",
            "gauge": {
               "value_type": "double"
            },
            "unit": "KiBy"
         }
      },
      "resource_attributes": {
         "mongodb_atlas.cluster.name": {
            "description": "Cluster Name",
            "enabled": false,
            "type": "string"
         },
         "mongodb_atlas.db.name": {
            "description": "Name of the Database",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.disk.partition": {
            "description": "Name of a disk partition",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.host.name": {
            "description": "Hostname of the process",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.org_name": {
            "description": "Organization Name",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.process.id": {
            "description": "ID of the process",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.process.port": {
            "description": "Port process is bound to",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.process.type_name": {
            "description": "Process type",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.project.id": {
            "description": "Project ID",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.project.name": {
            "description": "Project Name",
            "enabled": true,
            "type": "string"
         },
         "mongodb_atlas.provider.name": {
            "description": "Provider Name",
            "enabled": false,
            "type": "string"
         },
         "mongodb_atlas.region.name": {
            "description": "Region Name",
            "enabled": false,
            "type": "string"
         },
         "mongodb_atlas.user.alias": {
            "description": "User-friendly hostname of the cluster node",
            "enabled": false,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "schmikei"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics",
               "logs"
            ]
         }
      },
      "type": "mongodbatlas"
   },
   "mongodbreceiver": {
      "attributes": {
         "collection": {
            "description": "The name of a collection.",
            "type": "string"
         },
         "connection_type": {
            "description": "The status of the connection.",
            "enum": [
               "active",
               "available",
               "current"
            ],
            "name_override": "type",
            "type": "string"
         },
         "lock_mode": {
            "description": "The mode of Lock which denotes the degree of access",
            "enum": [
               "shared",
               "exclusive",
               "intent_shared",
               "intent_exclusive"
            ],
            "type": "string"
         },
         "lock_type": {
            "description": "The Resource over which the Lock controls access",
            "enum": [
               "parallel_batch_write_mode",
               "replication_state_transition",
               "global",
               "database",
               "collection",
               "mutex",
               "metadata",
               "oplog"
            ],
            "type": "string"
         },
         "memory_type": {
            "description": "The type of memory used.",
            "enum": [
               "resident",
               "virtual"
            ],
            "name_override": "type",
            "type": "string"
         },
         "operation": {
            "description": "The MongoDB operation being counted.",
            "enum": [
               "insert",
               "query",
               "update",
               "delete",
               "getmore",
               "command"
            ],
            "type": "string"
         },
         "operation_latency": {
            "description": "The MongoDB operation with regards to latency",
            "enum": [
               "read",
               "write",
               "command"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "type": {
            "description": "The result of a cache request.",
            "enum": [
               "hit",
               "miss"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "mongodb.cache.operations": {
            "attributes": [
               "type"
            ],
            "description": "The number of cache operations of the instance.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "mongodb.collection.count": {
            "attributes": [ ],
            "description": "The number of collections.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{collections}"
         },
         "mongodb.connection.count": {
            "attributes": [
               "connection_type"
            ],
            "description": "The number of connections.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "mongodb.cursor.count": {
            "attributes": [ ],
            "description": "The number of open cursors maintained for clients.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{cursors}"
         },
         "mongodb.cursor.timeout.count": {
            "attributes": [ ],
            "description": "The number of cursors that have timed out.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{cursors}"
         },
         "mongodb.data.size": {
            "attributes": [ ],
            "description": "The size of the collection. Data compression does not affect this value.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mongodb.database.count": {
            "attributes": [ ],
            "description": "The number of existing databases.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{databases}"
         },
         "mongodb.document.operation.count": {
            "attributes": [
               "operation"
            ],
            "description": "The number of document operations executed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{documents}"
         },
         "mongodb.extent.count": {
            "attributes": [ ],
            "description": "The number of extents.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{extents}"
         },
         "mongodb.global_lock.time": {
            "attributes": [ ],
            "description": "The time the global lock has been held.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "mongodb.health": {
            "attributes": [ ],
            "description": "The health status of the server.",
            "enabled": false,
            "extended_documentation": "A value of '1' indicates healthy. A value of '0' indicates unhealthy.",
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "mongodb.index.access.count": {
            "attributes": [
               "collection"
            ],
            "description": "The number of times an index has been accessed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{accesses}"
         },
         "mongodb.index.count": {
            "attributes": [ ],
            "description": "The number of indexes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{indexes}"
         },
         "mongodb.index.size": {
            "attributes": [ ],
            "description": "Sum of the space allocated to all indexes in the database, including free index space.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mongodb.lock.acquire.count": {
            "attributes": [
               "lock_type",
               "lock_mode"
            ],
            "description": "Number of times the lock was acquired in the specified mode.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "mongodb.lock.acquire.time": {
            "attributes": [
               "lock_type",
               "lock_mode"
            ],
            "description": "Cumulative wait time for the lock acquisitions.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "microseconds"
         },
         "mongodb.lock.acquire.wait_count": {
            "attributes": [
               "lock_type",
               "lock_mode"
            ],
            "description": "Number of times the lock acquisitions encountered waits because the locks were held in a conflicting mode.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "mongodb.lock.deadlock.count": {
            "attributes": [
               "lock_type",
               "lock_mode"
            ],
            "description": "Number of times the lock acquisitions encountered deadlocks.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "mongodb.memory.usage": {
            "attributes": [
               "memory_type"
            ],
            "description": "The amount of memory used.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mongodb.network.io.receive": {
            "attributes": [ ],
            "description": "The number of bytes received.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mongodb.network.io.transmit": {
            "attributes": [ ],
            "description": "The number of by transmitted.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mongodb.network.request.count": {
            "attributes": [ ],
            "description": "The number of requests received by the server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "mongodb.object.count": {
            "attributes": [ ],
            "description": "The number of objects.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{objects}"
         },
         "mongodb.operation.count": {
            "attributes": [
               "operation"
            ],
            "description": "The number of operations executed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "mongodb.operation.latency.time": {
            "attributes": [
               "operation_latency"
            ],
            "description": "The latency of operations.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "us"
         },
         "mongodb.operation.repl.count": {
            "attributes": [
               "operation"
            ],
            "description": "The number of replicated operations executed.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "mongodb.operation.time": {
            "attributes": [
               "operation"
            ],
            "description": "The total time spent performing operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "mongodb.session.count": {
            "attributes": [ ],
            "description": "The total number of active sessions.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "mongodb.storage.size": {
            "attributes": [ ],
            "description": "The total amount of storage allocated to this collection.",
            "enabled": true,
            "extended_documentation": "If collection data is compressed it reflects the compressed size.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mongodb.uptime": {
            "attributes": [ ],
            "description": "The amount of time that the server has been running.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         }
      },
      "resource_attributes": {
         "database": {
            "description": "The name of a database.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "schmikei"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "mongodb"
   },
   "mysqlreceiver": {
      "attributes": {
         "buffer_pool_data": {
            "description": "The status of buffer pool data.",
            "enum": [
               "dirty",
               "clean"
            ],
            "name_override": "status",
            "type": "string"
         },
         "buffer_pool_operations": {
            "description": "The buffer pool operations types.",
            "enum": [
               "read_ahead_rnd",
               "read_ahead",
               "read_ahead_evicted",
               "read_requests",
               "reads",
               "wait_free",
               "write_requests"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "buffer_pool_pages": {
            "description": "The buffer pool pages types.",
            "enum": [
               "data",
               "free",
               "misc"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "cache_status": {
            "description": "The status of cache access.",
            "enum": [
               "hit",
               "miss",
               "overflow"
            ],
            "name_override": "status",
            "type": "string"
         },
         "command": {
            "description": "The command types.",
            "enum": [
               "delete",
               "insert",
               "select",
               "update"
            ],
            "type": "string"
         },
         "connection_error": {
            "description": "The connection error type.",
            "enum": [
               "accept",
               "internal",
               "max_connections",
               "peer_address",
               "select",
               "tcpwrap",
               "aborted",
               "aborted_clients",
               "locked"
            ],
            "name_override": "error",
            "type": "string"
         },
         "connection_status": {
            "description": "The connection status.",
            "enum": [
               "accepted",
               "closed",
               "rejected"
            ],
            "name_override": "status",
            "type": "string"
         },
         "digest": {
            "description": "Digest.",
            "type": "string"
         },
         "digest_text": {
            "description": "Text before digestion.",
            "type": "string"
         },
         "direction": {
            "description": "The name of the transmission direction.",
            "enum": [
               "received",
               "sent"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "double_writes": {
            "description": "The doublewrite types.",
            "enum": [
               "pages_written",
               "writes"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "event_state": {
            "description": "Possible event states.",
            "enum": [
               "errors",
               "warnings",
               "rows_affected",
               "rows_sent",
               "rows_examined",
               "created_tmp_disk_tables",
               "created_tmp_tables",
               "sort_merge_passes",
               "sort_rows",
               "no_index_used"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "handler": {
            "description": "The handler types.",
            "enum": [
               "commit",
               "delete",
               "discover",
               "external_lock",
               "mrr_init",
               "prepare",
               "read_first",
               "read_key",
               "read_last",
               "read_next",
               "read_prev",
               "read_rnd",
               "read_rnd_next",
               "rollback",
               "savepoint",
               "savepoint_rollback",
               "update",
               "write"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "index_name": {
            "description": "The name of the index.",
            "name_override": "index",
            "type": "string"
         },
         "io_waits_operations": {
            "description": "The io_waits operation type.",
            "enum": [
               "delete",
               "fetch",
               "insert",
               "update"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "join_kind": {
            "description": "The kind of join.",
            "enum": [
               "full",
               "full_range",
               "range",
               "range_check",
               "scan"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "locks": {
            "description": "The table locks type.",
            "enum": [
               "immediate",
               "waited"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "log_operations": {
            "description": "The log operation types.",
            "enum": [
               "waits",
               "write_requests",
               "writes"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "mysqlx_threads": {
            "description": "The worker thread count kind.",
            "enum": [
               "available",
               "active"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "opened_resources": {
            "description": "The kind of the resource.",
            "enum": [
               "file",
               "table_definition",
               "table"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "operations": {
            "description": "The operation types.",
            "enum": [
               "fsyncs",
               "reads",
               "writes"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "page_operations": {
            "description": "The page operation types.",
            "enum": [
               "created",
               "read",
               "written"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "prepared_statements_command": {
            "description": "The prepare statement command types.",
            "enum": [
               "execute",
               "close",
               "fetch",
               "prepare",
               "reset",
               "send_long_data"
            ],
            "name_override": "command",
            "type": "string"
         },
         "read_lock_type": {
            "description": "Read operation types.",
            "enum": [
               "normal",
               "with_shared_locks",
               "high_priority",
               "no_insert",
               "external"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "row_locks": {
            "description": "The row lock type.",
            "enum": [
               "waits",
               "time"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "row_operations": {
            "description": "The row operation type.",
            "enum": [
               "deleted",
               "inserted",
               "read",
               "updated"
            ],
            "name_override": "operation",
            "type": "string"
         },
         "schema": {
            "description": "The schema of the object.",
            "type": "string"
         },
         "sorts": {
            "description": "The sort count type.",
            "enum": [
               "merge_passes",
               "range",
               "rows",
               "scan"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "table_name": {
            "description": "Table name for event or process.",
            "name_override": "table",
            "type": "string"
         },
         "threads": {
            "description": "The thread count type.",
            "enum": [
               "cached",
               "connected",
               "created",
               "running"
            ],
            "name_override": "kind",
            "type": "string"
         },
         "tmp_resource": {
            "description": "The kind of temporary resources.",
            "enum": [
               "disk_tables",
               "files",
               "tables"
            ],
            "name_override": "resource",
            "type": "string"
         },
         "write_lock_type": {
            "description": "Write operation types.",
            "enum": [
               "allow_write",
               "concurrent_insert",
               "low_priority",
               "normal",
               "external"
            ],
            "name_override": "kind",
            "type": "string"
         }
      },
      "metrics": {
         "mysql.buffer_pool.data_pages": {
            "attributes": [
               "buffer_pool_data"
            ],
            "description": "The number of data pages in the InnoDB buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.buffer_pool.limit": {
            "description": "The configured size of the InnoDB buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mysql.buffer_pool.operations": {
            "attributes": [
               "buffer_pool_operations"
            ],
            "description": "The number of operations on the InnoDB buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.buffer_pool.page_flushes": {
            "description": "The number of requests to flush pages from the InnoDB buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.buffer_pool.pages": {
            "attributes": [
               "buffer_pool_pages"
            ],
            "description": "The number of pages in the InnoDB buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.buffer_pool.usage": {
            "attributes": [
               "buffer_pool_data"
            ],
            "description": "The number of bytes in the InnoDB buffer pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mysql.client.network.io": {
            "attributes": [
               "direction"
            ],
            "description": "The number of transmitted bytes between server and clients.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "mysql.commands": {
            "attributes": [
               "command"
            ],
            "description": "The number of times each type of command has been executed.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.connection.count": {
            "description": "The number of connection attempts (successful or not) to the MySQL server.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.connection.errors": {
            "attributes": [
               "connection_error"
            ],
            "description": "Errors that occur during the client connection process.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.double_writes": {
            "attributes": [
               "double_writes"
            ],
            "description": "The number of writes to the InnoDB doublewrite buffer.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.handlers": {
            "attributes": [
               "handler"
            ],
            "description": "The number of requests to various MySQL handlers.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.index.io.wait.count": {
            "attributes": [
               "io_waits_operations",
               "table_name",
               "schema",
               "index_name"
            ],
            "description": "The total count of I/O wait events for an index.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.index.io.wait.time": {
            "attributes": [
               "io_waits_operations",
               "table_name",
               "schema",
               "index_name"
            ],
            "description": "The total time of I/O wait events for an index.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "mysql.joins": {
            "attributes": [
               "join_kind"
            ],
            "description": "The number of joins that perform table scans.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.locks": {
            "attributes": [
               "locks"
            ],
            "description": "The number of MySQL locks.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.log_operations": {
            "attributes": [
               "log_operations"
            ],
            "description": "The number of InnoDB log operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.mysqlx_connections": {
            "attributes": [
               "connection_status"
            ],
            "description": "The number of mysqlx connections.",
            "enabled": true,
            "extended_documentation": "This metric is specific for MySQL working as Document Store (X-Plugin). [more docs](https://dev.mysql.com/doc/refman/8.0/en/document-store.html)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.mysqlx_worker_threads": {
            "attributes": [
               "mysqlx_threads"
            ],
            "description": "The number of worker threads available.",
            "enabled": false,
            "extended_documentation": "This metric is specific for MySQL working as Document Store (X-Plugin). [more docs](https://dev.mysql.com/doc/refman/8.0/en/document-store.html)",
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.opened_resources": {
            "attributes": [
               "opened_resources"
            ],
            "description": "The number of opened resources.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.operations": {
            "attributes": [
               "operations"
            ],
            "description": "The number of InnoDB operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.page_operations": {
            "attributes": [
               "page_operations"
            ],
            "description": "The number of InnoDB page operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.prepared_statements": {
            "attributes": [
               "prepared_statements_command"
            ],
            "description": "The number of times each type of prepared statement command has been issued.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.query.client.count": {
            "description": "The number of statements executed by the server. This includes only statements sent to the server by clients.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.query.count": {
            "description": "The number of statements executed by the server.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.query.slow.count": {
            "description": "The number of slow queries.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.replica.sql_delay": {
            "attributes": [ ],
            "description": "The number of seconds that the replica must lag the source.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "s"
         },
         "mysql.replica.time_behind_source": {
            "attributes": [ ],
            "description": "This field is an indication of how late the replica is.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "s"
         },
         "mysql.row_locks": {
            "attributes": [
               "row_locks"
            ],
            "description": "The number of InnoDB row locks.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.row_operations": {
            "attributes": [
               "row_operations"
            ],
            "description": "The number of InnoDB row operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.sorts": {
            "attributes": [
               "sorts"
            ],
            "description": "The number of MySQL sorts.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.statement_event.count": {
            "attributes": [
               "schema",
               "digest",
               "digest_text",
               "event_state"
            ],
            "description": "Summary of current and recent statement events.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.statement_event.wait.time": {
            "attributes": [
               "schema",
               "digest",
               "digest_text"
            ],
            "description": "The total wait time of the summarized timed events.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "mysql.table.io.wait.count": {
            "attributes": [
               "io_waits_operations",
               "table_name",
               "schema"
            ],
            "description": "The total count of I/O wait events for a table.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.table.io.wait.time": {
            "attributes": [
               "io_waits_operations",
               "table_name",
               "schema"
            ],
            "description": "The total time of I/O wait events for a table.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "mysql.table.lock_wait.read.count": {
            "attributes": [
               "schema",
               "table_name",
               "read_lock_type"
            ],
            "description": "The total table lock wait read events.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "1"
         },
         "mysql.table.lock_wait.read.time": {
            "attributes": [
               "schema",
               "table_name",
               "read_lock_type"
            ],
            "description": "The total table lock wait read events times.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "mysql.table.lock_wait.write.count": {
            "attributes": [
               "schema",
               "table_name",
               "write_lock_type"
            ],
            "description": "The total table lock wait write events.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "1"
         },
         "mysql.table.lock_wait.write.time": {
            "attributes": [
               "schema",
               "table_name",
               "write_lock_type"
            ],
            "description": "The total table lock wait write events times.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "ns"
         },
         "mysql.table_open_cache": {
            "attributes": [
               "cache_status"
            ],
            "description": "The number of hits, misses or overflows for open tables cache lookups.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.threads": {
            "attributes": [
               "threads"
            ],
            "description": "The state of MySQL threads.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.tmp_resources": {
            "attributes": [
               "tmp_resource"
            ],
            "description": "The number of created temporary resources.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "mysql.uptime": {
            "description": "The number of seconds that the server has been up.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         }
      },
      "resource_attributes": {
         "mysql.instance.endpoint": {
            "description": "Endpoint of the MySQL instance.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "mysql"
   },
   "namedpipereceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "type": "namedpipe"
   },
   "networkscraper": {
      "attributes": {
         "device": {
            "description": "Name of the network interface.",
            "type": "string"
         },
         "direction": {
            "description": "Direction of flow of bytes/operations (receive or transmit).",
            "enum": [
               "receive",
               "transmit"
            ],
            "type": "string"
         },
         "protocol": {
            "description": "Network protocol, e.g. TCP or UDP.",
            "enum": [
               "tcp"
            ],
            "type": "string"
         },
         "state": {
            "description": "State of the network connection.",
            "type": "string"
         }
      },
      "metrics": {
         "system.network.connections": {
            "attributes": [
               "protocol",
               "state"
            ],
            "description": "The number of connections.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "system.network.conntrack.count": {
            "description": "The count of entries in conntrack table.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{entries}"
         },
         "system.network.conntrack.max": {
            "description": "The limit for entries in the conntrack table.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{entries}"
         },
         "system.network.dropped": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "The number of packets dropped.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "system.network.errors": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "The number of errors encountered.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "system.network.io": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "The number of bytes transmitted and received.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.network.packets": {
            "attributes": [
               "device",
               "direction"
            ],
            "description": "The number of packets transferred.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/network"
   },
   "nginxreceiver": {
      "attributes": {
         "state": {
            "description": "The state of a connection",
            "enum": [
               "active",
               "reading",
               "writing",
               "waiting"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "nginx.connections_accepted": {
            "attributes": [ ],
            "description": "The total number of accepted client connections",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "connections"
         },
         "nginx.connections_current": {
            "attributes": [
               "state"
            ],
            "description": "The current number of nginx connections by state",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "connections"
         },
         "nginx.connections_handled": {
            "attributes": [ ],
            "description": "The total number of handled connections. Generally, the parameter value is the same as nginx.connections_accepted unless some resource limits have been reached (for example, the worker_connections limit).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "connections"
         },
         "nginx.requests": {
            "attributes": [ ],
            "description": "Total number of requests made to the server since it started",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "requests"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "nginx"
   },
   "nsxtreceiver": {
      "attributes": {
         "class": {
            "description": "The CPU usage of the architecture allocated for either DPDK (datapath) or non-DPDK (services) processes.",
            "enum": [
               "datapath",
               "services"
            ],
            "type": "string"
         },
         "direction": {
            "description": "The direction of network flow.",
            "enum": [
               "received",
               "transmitted"
            ],
            "type": "string"
         },
         "disk_state": {
            "description": "The state of storage space.",
            "enum": [
               "used",
               "available"
            ],
            "name_override": "state",
            "type": "string"
         },
         "packet.type": {
            "description": "The type of packet counter.",
            "enum": [
               "dropped",
               "errored",
               "success"
            ],
            "name_override": "type",
            "type": "string"
         }
      },
      "metrics": {
         "nsxt.node.cpu.utilization": {
            "attributes": [
               "class"
            ],
            "description": "The average amount of CPU being used by the node.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "nsxt.node.filesystem.usage": {
            "attributes": [
               "disk_state"
            ],
            "description": "The amount of storage space used by the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "nsxt.node.filesystem.utilization": {
            "description": "The percentage of storage space utilized.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "nsxt.node.memory.cache.usage": {
            "description": "The size of the node's memory cache.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "KBy"
         },
         "nsxt.node.memory.usage": {
            "description": "The memory usage of the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "KBy"
         },
         "nsxt.node.network.io": {
            "attributes": [
               "direction"
            ],
            "description": "The number of bytes which have flowed through the network interface.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "nsxt.node.network.packet.count": {
            "attributes": [
               "direction",
               "packet.type"
            ],
            "description": "The number of packets which have flowed through the network interface on the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         }
      },
      "resource_attributes": {
         "device.id": {
            "description": "The name of the network interface.",
            "enabled": true,
            "type": "string"
         },
         "nsxt.node.id": {
            "description": "The ID of the NSX Node.",
            "enabled": true,
            "type": "string"
         },
         "nsxt.node.name": {
            "description": "The name of the NSX Node.",
            "enabled": true,
            "type": "string"
         },
         "nsxt.node.type": {
            "description": "The type of NSX Node.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dashpole",
               "schmikei"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "nsxt"
   },
   "opencensusexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "open-telemetry/collector-approvers"
            ]
         },
         "distributions": [
            "contrib",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics"
            ]
         }
      },
      "type": "opencensus"
   },
   "opencensusreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "open-telemetry/collector-approvers"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "grafana",
            "observiq",
            "redhat",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics",
               "traces"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "opencensus"
   },
   "opensearchexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "MitchellGale",
               "MaxKsyunz",
               "YANG-DB"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "traces"
            ],
            "development": [
               "logs"
            ]
         }
      },
      "type": "opensearch"
   },
   "openshift": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "cloud.platform": {
            "description": "The cloud.platform",
            "enabled": true,
            "type": "string"
         },
         "cloud.provider": {
            "description": "The cloud.provider",
            "enabled": true,
            "type": "string"
         },
         "cloud.region": {
            "description": "The cloud.region",
            "enabled": true,
            "type": "string"
         },
         "k8s.cluster.name": {
            "description": "The k8s.cluster.name",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "frzifus"
            ]
         }
      },
      "type": "resourcedetectionprocessor/openshift"
   },
   "oracledbreceiver": {
      "attributes": {
         "session_status": {
            "description": "Session status",
            "type": "string"
         },
         "session_type": {
            "description": "Session type",
            "type": "string"
         },
         "tablespace_name": {
            "description": "Tablespace name",
            "type": "string"
         }
      },
      "metrics": {
         "oracledb.consistent_gets": {
            "description": "Number of times a consistent read was requested for a block from the buffer cache.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{gets}"
         },
         "oracledb.cpu_time": {
            "description": "Cumulative CPU time, in seconds",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "oracledb.db_block_gets": {
            "description": "Number of times a current block was requested from the buffer cache.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{gets}"
         },
         "oracledb.dml_locks.limit": {
            "description": "Maximum limit of active DML (Data Manipulation Language) locks, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{locks}"
         },
         "oracledb.dml_locks.usage": {
            "description": "Current count of active DML (Data Manipulation Language) locks.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{locks}"
         },
         "oracledb.enqueue_deadlocks": {
            "description": "Total number of deadlocks between table or row locks in different sessions.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{deadlocks}"
         },
         "oracledb.enqueue_locks.limit": {
            "description": "Maximum limit of active enqueue locks, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{locks}"
         },
         "oracledb.enqueue_locks.usage": {
            "description": "Current count of active enqueue locks.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{locks}"
         },
         "oracledb.enqueue_resources.limit": {
            "description": "Maximum limit of active enqueue resources, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{resources}"
         },
         "oracledb.enqueue_resources.usage": {
            "description": "Current count of active enqueue resources.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{resources}"
         },
         "oracledb.exchange_deadlocks": {
            "description": "Number of times that a process detected a potential deadlock when exchanging two buffers and raised an internal, restartable error. Index scans are the only operations that perform exchanges.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{deadlocks}"
         },
         "oracledb.executions": {
            "description": "Total number of calls (user and recursive) that executed SQL statements",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{executions}"
         },
         "oracledb.hard_parses": {
            "description": "Number of hard parses",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{parses}"
         },
         "oracledb.logical_reads": {
            "description": "Number of logical reads",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{reads}"
         },
         "oracledb.parse_calls": {
            "description": "Total number of parse calls.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{parses}"
         },
         "oracledb.pga_memory": {
            "description": "Session PGA (Program Global Area) memory",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "oracledb.physical_reads": {
            "description": "Number of physical reads",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{reads}"
         },
         "oracledb.processes.limit": {
            "description": "Maximum limit of active processes, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{processes}"
         },
         "oracledb.processes.usage": {
            "description": "Current count of active processes.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{processes}"
         },
         "oracledb.sessions.limit": {
            "description": "Maximum limit of active sessions, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "oracledb.sessions.usage": {
            "attributes": [
               "session_type",
               "session_status"
            ],
            "description": "Count of active sessions.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{sessions}"
         },
         "oracledb.tablespace_size.limit": {
            "attributes": [
               "tablespace_name"
            ],
            "description": "Maximum size of tablespace in bytes, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "oracledb.tablespace_size.usage": {
            "attributes": [
               "tablespace_name"
            ],
            "description": "Used tablespace in bytes.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "By"
         },
         "oracledb.transactions.limit": {
            "description": "Maximum limit of active transactions, -1 if unlimited.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{transactions}"
         },
         "oracledb.transactions.usage": {
            "description": "Current count of active transactions.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "{transactions}"
         },
         "oracledb.user_commits": {
            "description": "Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{commits}"
         },
         "oracledb.user_rollbacks": {
            "description": "Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         }
      },
      "resource_attributes": {
         "oracledb.instance.name": {
            "description": "The name of the instance that data is coming from.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "crobert-1",
               "atoulme"
            ]
         },
         "distributions": [
            "contrib",
            "splunk"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "oracledb"
   },
   "otlpexporter": {
      "status": {
         "class": "exporter",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "beta": [
               "logs"
            ],
            "stable": [
               "traces",
               "metrics"
            ]
         }
      },
      "type": "otlp"
   },
   "otlphttpexporter": {
      "status": {
         "class": "exporter",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "beta": [
               "logs"
            ],
            "stable": [
               "traces",
               "metrics"
            ]
         }
      },
      "type": "otlphttp"
   },
   "otlpjsonfilereceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "atoulme"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "include": [
               "/tmp/*.log"
            ]
         }
      },
      "type": "otlpjsonfile"
   },
   "otlpreceiver": {
      "status": {
         "class": "receiver",
         "distributions": [
            "core",
            "contrib"
         ],
         "stability": {
            "beta": [
               "logs"
            ],
            "stable": [
               "traces",
               "metrics"
            ]
         }
      },
      "type": "otlp"
   },
   "pagingscraper": {
      "attributes": {
         "device": {
            "description": "Name of the page file.",
            "type": "string"
         },
         "direction": {
            "description": "Page In or Page Out.",
            "enum": [
               "page_in",
               "page_out"
            ],
            "type": "string"
         },
         "state": {
            "description": "Breakdown of paging usage by type.",
            "enum": [
               "cached",
               "free",
               "used"
            ],
            "type": "string"
         },
         "type": {
            "description": "Type of fault.",
            "enum": [
               "major",
               "minor"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "system.paging.faults": {
            "attributes": [
               "type"
            ],
            "description": "The number of page faults.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{faults}"
         },
         "system.paging.operations": {
            "attributes": [
               "direction",
               "type"
            ],
            "description": "The number of paging operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "system.paging.usage": {
            "attributes": [
               "device",
               "state"
            ],
            "description": "Swap (unix) or pagefile (windows) usage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "system.paging.utilization": {
            "attributes": [
               "device",
               "state"
            ],
            "description": "Swap (unix) or pagefile (windows) utilization.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/paging"
   },
   "podmanreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "rogercoll"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "podman_stats"
   },
   "postgresqlreceiver": {
      "attributes": {
         "bg_buffer_source": {
            "description": "The source of a buffer write.",
            "enum": [
               "backend",
               "backend_fsync",
               "checkpoints",
               "bgwriter"
            ],
            "name_override": "source",
            "type": "string"
         },
         "bg_checkpoint_type": {
            "description": "The type of checkpoint state.",
            "enum": [
               "requested",
               "scheduled"
            ],
            "name_override": "type",
            "type": "string"
         },
         "bg_duration_type": {
            "description": "The type of time spent during the checkpoint.",
            "enum": [
               "sync",
               "write"
            ],
            "name_override": "type",
            "type": "string"
         },
         "lock_type": {
            "description": "Type of the lockable object.",
            "type": "string"
         },
         "mode": {
            "description": "Name of the lock mode held or desired by the process.",
            "type": "string"
         },
         "operation": {
            "description": "The database operation.",
            "enum": [
               "ins",
               "upd",
               "del",
               "hot_upd"
            ],
            "type": "string"
         },
         "relation": {
            "description": "OID of the relation targeted by the lock, or null if the target is not a relation or part of a relation.",
            "type": "string"
         },
         "replication_client": {
            "description": "The IP address of the client connected to this backend. If this field is \"unix\", it indicates either that the client is connected via a Unix socket.",
            "type": "string"
         },
         "source": {
            "description": "The block read source type.",
            "enum": [
               "heap_read",
               "heap_hit",
               "idx_read",
               "idx_hit",
               "toast_read",
               "toast_hit",
               "tidx_read",
               "tidx_hit"
            ],
            "type": "string"
         },
         "state": {
            "description": "The tuple (row) state.",
            "enum": [
               "dead",
               "live"
            ],
            "type": "string"
         },
         "wal_operation_lag": {
            "description": "The operation which is responsible for the lag.",
            "enum": [
               "flush",
               "replay",
               "write"
            ],
            "name_override": "operation",
            "type": "string"
         }
      },
      "metrics": {
         "postgresql.backends": {
            "description": "The number of backends.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.bgwriter.buffers.allocated": {
            "description": "Number of buffers allocated.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{buffers}"
         },
         "postgresql.bgwriter.buffers.writes": {
            "attributes": [
               "bg_buffer_source"
            ],
            "description": "Number of buffers written.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{buffers}"
         },
         "postgresql.bgwriter.checkpoint.count": {
            "attributes": [
               "bg_checkpoint_type"
            ],
            "description": "The number of checkpoints performed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{checkpoints}"
         },
         "postgresql.bgwriter.duration": {
            "attributes": [
               "bg_duration_type"
            ],
            "description": "Total time spent writing and syncing files to disk by checkpoints.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "ms"
         },
         "postgresql.bgwriter.maxwritten": {
            "description": "Number of times the background writer stopped a cleaning scan because it had written too many buffers.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.blocks_read": {
            "attributes": [
               "source"
            ],
            "description": "The number of blocks read.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.commits": {
            "description": "The number of commits.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.connection.max": {
            "description": "Configured maximum number of client connections allowed",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "postgresql.database.count": {
            "description": "Number of user databases.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{databases}"
         },
         "postgresql.database.locks": {
            "attributes": [
               "relation",
               "mode",
               "lock_type"
            ],
            "description": "The number of database locks.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{lock}"
         },
         "postgresql.db_size": {
            "description": "The database disk usage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "postgresql.deadlocks": {
            "description": "The number of deadlocks.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{deadlock}"
         },
         "postgresql.index.scans": {
            "description": "The number of index scans on a table.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{scans}"
         },
         "postgresql.index.size": {
            "description": "The size of the index on disk.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "postgresql.operations": {
            "attributes": [
               "operation"
            ],
            "description": "The number of db row operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.replication.data_delay": {
            "attributes": [
               "replication_client"
            ],
            "description": "The amount of data delayed in replication.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "postgresql.rollbacks": {
            "description": "The number of rollbacks.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.rows": {
            "attributes": [
               "state"
            ],
            "description": "The number of rows in the database.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "postgresql.sequential_scans": {
            "description": "The number of sequential scans.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{sequential_scan}"
         },
         "postgresql.table.count": {
            "description": "Number of user tables in a database.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{table}"
         },
         "postgresql.table.size": {
            "description": "Disk space used by a table.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "postgresql.table.vacuum.count": {
            "description": "Number of times a table has manually been vacuumed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{vacuums}"
         },
         "postgresql.temp_files": {
            "description": "The number of temp files.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{temp_file}"
         },
         "postgresql.wal.age": {
            "description": "Age of the oldest WAL file.",
            "enabled": true,
            "extended_documentation": "This metric requires WAL to be enabled with at least one replica.\n",
            "gauge": {
               "value_type": "int"
            },
            "unit": "s"
         },
         "postgresql.wal.delay": {
            "attributes": [
               "wal_operation_lag",
               "replication_client"
            ],
            "description": "Time between flushing recent WAL locally and receiving notification that the standby server has completed an operation with it.",
            "enabled": false,
            "extended_documentation": "This metric requires WAL to be enabled with at least one replica.\n",
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "postgresql.wal.lag": {
            "attributes": [
               "wal_operation_lag",
               "replication_client"
            ],
            "description": "Time between flushing recent WAL locally and receiving notification that the standby server has completed an operation with it.",
            "enabled": true,
            "extended_documentation": "This metric requires WAL to be enabled with at least one replica.\n",
            "gauge": {
               "value_type": "int"
            },
            "unit": "s"
         }
      },
      "resource_attributes": {
         "postgresql.database.name": {
            "description": "The name of the database.",
            "enabled": true,
            "type": "string"
         },
         "postgresql.index.name": {
            "description": "The name of the index on a table.",
            "enabled": true,
            "type": "string"
         },
         "postgresql.table.name": {
            "description": "The schema name followed by the table name.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "postgresql"
   },
   "probabilisticsamplerprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "jpkrohling"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "aws",
            "grafana"
         ],
         "stability": {
            "alpha": [
               "logs"
            ],
            "beta": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "probabilistic_sampler"
   },
   "processesscraper": {
      "attributes": {
         "status": {
            "description": "Breakdown status of the processes.",
            "enum": [
               "blocked",
               "daemon",
               "detached",
               "idle",
               "locked",
               "orphan",
               "paging",
               "running",
               "sleeping",
               "stopped",
               "system",
               "unknown",
               "zombies"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "system.processes.count": {
            "attributes": [
               "status"
            ],
            "description": "Total number of processes in each state.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{processes}"
         },
         "system.processes.created": {
            "description": "Total number of created processes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{processes}"
         }
      },
      "parent": "hostmetrics",
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/processes"
   },
   "processscraper": {
      "attributes": {
         "context_switch_type": {
            "description": "Type of context switched.",
            "enum": [
               "involuntary",
               "voluntary"
            ],
            "name_override": "type",
            "type": "string"
         },
         "direction": {
            "description": "Direction of flow of bytes (read or write).",
            "enum": [
               "read",
               "write"
            ],
            "type": "string"
         },
         "paging_fault_type": {
            "description": "Type of memory paging fault.",
            "enum": [
               "major",
               "minor"
            ],
            "name_override": "type",
            "type": "string"
         },
         "state": {
            "description": "Breakdown of CPU usage by type.",
            "enum": [
               "system",
               "user",
               "wait"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "process.context_switches": {
            "attributes": [
               "context_switch_type"
            ],
            "description": "Number of times the process has been context switched.",
            "enabled": false,
            "extended_documentation": "This metric is only available on Linux.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "process.cpu.time": {
            "attributes": [
               "state"
            ],
            "description": "Total CPU seconds broken down by different states.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "process.cpu.utilization": {
            "attributes": [
               "state"
            ],
            "description": "Percentage of total CPU time used by the process since last scrape, expressed as a value between 0 and 1. On the first scrape, no data point is emitted for this metric.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "process.disk.io": {
            "attributes": [
               "direction"
            ],
            "description": "Disk bytes transferred.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.disk.operations": {
            "attributes": [
               "direction"
            ],
            "description": "Number of disk operations performed by the process.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "process.handles": {
            "description": "Number of handles held by the process.",
            "enabled": false,
            "extended_documentation": "This metric is only available on Windows.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "process.memory.usage": {
            "description": "The amount of physical memory in use.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.memory.utilization": {
            "description": "Percentage of total physical memory that is used by the process.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "process.memory.virtual": {
            "description": "Virtual memory size.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "process.open_file_descriptors": {
            "description": "Number of file descriptors in use by the process.",
            "enabled": false,
            "extended_documentation": "This metric is only available on Linux.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{count}"
         },
         "process.paging.faults": {
            "attributes": [
               "paging_fault_type"
            ],
            "description": "Number of page faults the process has made.",
            "enabled": false,
            "extended_documentation": "This metric is only available on Linux.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{faults}"
         },
         "process.signals_pending": {
            "description": "Number of pending signals for the process.",
            "enabled": false,
            "extended_documentation": "This metric is only available on Linux.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{signals}"
         },
         "process.threads": {
            "description": "Process threads count.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         }
      },
      "parent": "hostmetrics",
      "resource_attributes": {
         "process.command": {
            "description": "The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in proc/[pid]/cmdline. On Windows, can be set to the first parameter extracted from GetCommandLineW.",
            "enabled": true,
            "type": "string"
         },
         "process.command_line": {
            "description": "The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of GetCommandLineW. Do not set this if you have to assemble it just for monitoring; use process.command_args instead.",
            "enabled": true,
            "type": "string"
         },
         "process.executable.name": {
            "description": "The name of the process executable. On Linux based systems, can be set to the Name in proc/[pid]/status. On Windows, can be set to the base name of GetProcessImageFileNameW.",
            "enabled": true,
            "type": "string"
         },
         "process.executable.path": {
            "description": "The full path to the process executable. On Linux based systems, can be set to the target of proc/[pid]/exe. On Windows, can be set to the result of GetProcessImageFileNameW.",
            "enabled": true,
            "type": "string"
         },
         "process.owner": {
            "description": "The username of the user that owns the process.",
            "enabled": true,
            "type": "string"
         },
         "process.parent_pid": {
            "description": "Parent Process identifier (PPID).",
            "enabled": true,
            "type": "int"
         },
         "process.pid": {
            "description": "Process identifier (PID).",
            "enabled": true,
            "type": "int"
         }
      },
      "sem_conv_version": "1.9.0",
      "type": "hostmetricsreceiver/process"
   },
   "prometheusexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "Aneurysm9"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "redhat",
            "sumo",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "prometheus"
   },
   "prometheusreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "dashpole"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "splunk",
            "sumo",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": {
            "config": {
               "scrape_configs": [
                  {
                     "job_name": "test"
                  }
               ]
            }
         }
      },
      "type": "prometheus"
   },
   "prometheusremotewriteexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "rapphil"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "aws",
            "observiq",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "prometheusremotewrite"
   },
   "pulsarexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "dmitryax",
               "dao-jun"
            ]
         },
         "distributions": [
            "contrib",
            "splunk"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "type": "pulsar"
   },
   "pulsarreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "dao-jun"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "metrics",
               "traces",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "pulsar"
   },
   "purefareceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "jpkrohling",
               "dgoscn",
               "chrroberts-pure"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "purefa"
   },
   "purefbreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "jpkrohling",
               "dgoscn",
               "chrroberts-pure"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "purefb"
   },
   "rabbitmqreceiver": {
      "attributes": {
         "message.state": {
            "description": "The state of messages in a queue.",
            "enum": [
               "ready",
               "unacknowledged"
            ],
            "name_override": "state",
            "type": "string"
         }
      },
      "metrics": {
         "rabbitmq.consumer.count": {
            "description": "The number of consumers currently reading from the queue.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{consumers}"
         },
         "rabbitmq.message.acknowledged": {
            "description": "The number of messages acknowledged by consumers.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{messages}"
         },
         "rabbitmq.message.current": {
            "attributes": [
               "message.state"
            ],
            "description": "The total number of messages currently in the queue.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{messages}"
         },
         "rabbitmq.message.delivered": {
            "description": "The number of messages delivered to consumers.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{messages}"
         },
         "rabbitmq.message.dropped": {
            "description": "The number of messages dropped as unroutable.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{messages}"
         },
         "rabbitmq.message.published": {
            "description": "The number of messages published to a queue.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{messages}"
         }
      },
      "resource_attributes": {
         "rabbitmq.node.name": {
            "description": "The name of the RabbitMQ node.",
            "enabled": true,
            "type": "string"
         },
         "rabbitmq.queue.name": {
            "description": "The name of the RabbitMQ queue.",
            "enabled": true,
            "type": "string"
         },
         "rabbitmq.vhost.name": {
            "description": "The name of the RabbitMQ vHost.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "cpheps"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "rabbitmq"
   },
   "receivercreator": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "rmfitzpatrick"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs",
               "traces"
            ],
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "receiver_creator"
   },
   "redactionprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "dmitryax",
               "mx-psi",
               "TylerHelmuth"
            ],
            "emeritus": [
               "leonsp-ai"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "redaction"
   },
   "redisreceiver": {
      "attributes": {
         "cmd": {
            "description": "Redis command name",
            "type": "string"
         },
         "db": {
            "description": "Redis database identifier",
            "type": "string"
         },
         "percentile": {
            "description": "Percentile",
            "enum": [
               "p50",
               "p99",
               "p99.9"
            ],
            "type": "string"
         },
         "role": {
            "description": "Redis node's role",
            "enum": [
               "replica",
               "primary"
            ],
            "type": "string"
         },
         "state": {
            "description": "Redis CPU usage state",
            "enum": [
               "sys",
               "sys_children",
               "sys_main_thread",
               "user",
               "user_children",
               "user_main_thread"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "redis.clients.blocked": {
            "description": "Number of clients pending on a blocking call",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{client}"
         },
         "redis.clients.connected": {
            "description": "Number of client connections (excluding connections from replicas)",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{client}"
         },
         "redis.clients.max_input_buffer": {
            "description": "Biggest input buffer among current client connections",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.clients.max_output_buffer": {
            "description": "Longest output list among current client connections",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.cmd.calls": {
            "attributes": [
               "cmd"
            ],
            "description": "Total number of calls for a command",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{call}"
         },
         "redis.cmd.latency": {
            "attributes": [
               "cmd",
               "percentile"
            ],
            "description": "Command execution latency",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "redis.cmd.usec": {
            "attributes": [
               "cmd"
            ],
            "description": "Total time for all executions of this command",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "us"
         },
         "redis.commands": {
            "description": "Number of commands processed per second",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{ops}/s"
         },
         "redis.commands.processed": {
            "description": "Total number of commands processed by the server",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{command}"
         },
         "redis.connections.received": {
            "description": "Total number of connections accepted by the server",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{connection}"
         },
         "redis.connections.rejected": {
            "description": "Number of connections rejected because of maxclients limit",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{connection}"
         },
         "redis.cpu.time": {
            "attributes": [
               "state"
            ],
            "description": "System CPU consumed by the Redis server in seconds since server start",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "double"
            },
            "unit": "s"
         },
         "redis.db.avg_ttl": {
            "attributes": [
               "db"
            ],
            "description": "Average keyspace keys TTL",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "redis.db.expires": {
            "attributes": [
               "db"
            ],
            "description": "Number of keyspace keys with an expiration",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{key}"
         },
         "redis.db.keys": {
            "attributes": [
               "db"
            ],
            "description": "Number of keyspace keys",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{key}"
         },
         "redis.keys.evicted": {
            "description": "Number of evicted keys due to maxmemory limit",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{key}"
         },
         "redis.keys.expired": {
            "description": "Total number of key expiration events",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{event}"
         },
         "redis.keyspace.hits": {
            "description": "Number of successful lookup of keys in the main dictionary",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{hit}"
         },
         "redis.keyspace.misses": {
            "description": "Number of failed lookup of keys in the main dictionary",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{miss}"
         },
         "redis.latest_fork": {
            "description": "Duration of the latest fork operation in microseconds",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "us"
         },
         "redis.maxmemory": {
            "description": "The value of the maxmemory configuration directive",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.memory.fragmentation_ratio": {
            "description": "Ratio between used_memory_rss and used_memory",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "redis.memory.lua": {
            "description": "Number of bytes used by the Lua engine",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.memory.peak": {
            "description": "Peak memory consumed by Redis (in bytes)",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.memory.rss": {
            "description": "Number of bytes that Redis allocated as seen by the operating system",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.memory.used": {
            "description": "Total number of bytes allocated by Redis using its allocator",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.net.input": {
            "description": "The total number of bytes read from the network",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.net.output": {
            "description": "The total number of bytes written to the network",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.rdb.changes_since_last_save": {
            "description": "Number of changes since the last dump",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{change}"
         },
         "redis.replication.backlog_first_byte_offset": {
            "description": "The master offset of the replication backlog buffer",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.replication.offset": {
            "description": "The server's current replication offset",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.replication.replica_offset": {
            "description": "Offset for redis replica",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "redis.role": {
            "attributes": [
               "role"
            ],
            "description": "Redis node's role",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{role}"
         },
         "redis.slaves.connected": {
            "description": "Number of connected replicas",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{replica}"
         },
         "redis.uptime": {
            "description": "Number of seconds since Redis server start",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "s"
         }
      },
      "resource_attributes": {
         "redis.version": {
            "description": "Redis server's version.",
            "enabled": true,
            "type": "string"
         },
         "server.address": {
            "description": "Redis server's address",
            "enabled": false,
            "type": "string"
         },
         "server.port": {
            "description": "Redis server's port",
            "enabled": false,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "hughesjj"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": {
            "endpoint": "localhost:6379"
         }
      },
      "type": "redis"
   },
   "remotetapprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "pmcollins"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "logs",
               "metrics",
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "remotetap"
   },
   "resourcedetectionprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "Aneurysm9",
               "dashpole"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo",
            "aws",
            "redhat",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "resourcedetection"
   },
   "resourceprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "dmitryax"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "splunk",
            "observiq",
            "sumo",
            "aws",
            "redhat",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "resource"
   },
   "riakreceiver": {
      "attributes": {
         "operation": {
            "description": "The operation type for index operations.",
            "enum": [
               "read",
               "write",
               "delete"
            ],
            "type": "string"
         },
         "request": {
            "description": "The request operation type.",
            "enum": [
               "put",
               "get"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "riak.memory.limit": {
            "description": "The amount of memory allocated to the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "riak.node.operation.count": {
            "attributes": [
               "request"
            ],
            "description": "The number of operations performed by the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operation}"
         },
         "riak.node.operation.time.mean": {
            "attributes": [
               "request"
            ],
            "description": "The mean time between request and response for operations performed by the node over the last minute.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "us"
         },
         "riak.node.read_repair.count": {
            "description": "The number of read repairs performed by the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{read_repair}"
         },
         "riak.vnode.index.operation.count": {
            "attributes": [
               "operation"
            ],
            "description": "The number of index operations performed by vnodes on the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{operation}"
         },
         "riak.vnode.operation.count": {
            "attributes": [
               "request"
            ],
            "description": "The number of operations performed by vnodes on the node.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operation}"
         }
      },
      "resource_attributes": {
         "riak.node.name": {
            "description": "The name this node uses to identify itself.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "armstrmi"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "riak"
   },
   "routingprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "jpkrohling"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "redhat"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "routing"
   },
   "saphanareceiver": {
      "attributes": {
         "active_pending_request_state": {
            "description": "The state of network request.",
            "enum": [
               "active",
               "pending"
            ],
            "name_override": "state",
            "type": "string"
         },
         "alert_rating": {
            "description": "The alert rating.",
            "name_override": "rating",
            "type": "string"
         },
         "column_memory_subtype": {
            "description": "The subtype of column store memory.",
            "enum": [
               "data",
               "dict",
               "index",
               "misc"
            ],
            "name_override": "subtype",
            "type": "string"
         },
         "column_memory_type": {
            "description": "The type of column store memory.",
            "enum": [
               "main",
               "delta"
            ],
            "name_override": "type",
            "type": "string"
         },
         "component": {
            "description": "The SAP HANA component.",
            "type": "string"
         },
         "connection_status": {
            "description": "The connection status.",
            "enum": [
               "running",
               "idle",
               "queueing"
            ],
            "name_override": "status",
            "type": "string"
         },
         "cpu_type": {
            "description": "The type of cpu.",
            "enum": [
               "user",
               "system",
               "io_wait",
               "idle"
            ],
            "name_override": "type",
            "type": "string"
         },
         "database": {
            "description": "The SAP HANA database.",
            "type": "string"
         },
         "disk_state_used_free": {
            "description": "The state of the disk storage.",
            "enum": [
               "used",
               "free"
            ],
            "name_override": "state",
            "type": "string"
         },
         "disk_usage_type": {
            "description": "The SAP HANA disk & volume usage type.",
            "name_override": "usage_type",
            "type": "string"
         },
         "host_swap_state": {
            "description": "The state of swap data.",
            "enum": [
               "used",
               "free"
            ],
            "name_override": "state",
            "type": "string"
         },
         "internal_external_request_type": {
            "description": "The type of network request.",
            "enum": [
               "internal",
               "external"
            ],
            "name_override": "type",
            "type": "string"
         },
         "memory_state_used_free": {
            "description": "The state of memory.",
            "enum": [
               "used",
               "free"
            ],
            "name_override": "state",
            "type": "string"
         },
         "path": {
            "description": "The SAP HANA disk path.",
            "type": "string"
         },
         "port": {
            "description": "The SAP HANA port.",
            "type": "string"
         },
         "primary_host": {
            "description": "The primary SAP HANA host in replication.",
            "name_override": "primary",
            "type": "string"
         },
         "product": {
            "description": "The SAP HANA product.",
            "type": "string"
         },
         "replication_mode": {
            "description": "The replication mode.",
            "name_override": "mode",
            "type": "string"
         },
         "row_memory_type": {
            "description": "The type of row store memory.",
            "enum": [
               "fixed",
               "variable"
            ],
            "name_override": "type",
            "type": "string"
         },
         "schema": {
            "description": "The SAP HANA schema.",
            "type": "string"
         },
         "schema_memory_type": {
            "description": "The type of schema memory.",
            "enum": [
               "main",
               "delta",
               "history_main",
               "history_delta"
            ],
            "name_override": "type",
            "type": "string"
         },
         "schema_operation_type": {
            "description": "The type of operation.",
            "enum": [
               "read",
               "write",
               "merge"
            ],
            "name_override": "type",
            "type": "string"
         },
         "schema_record_type": {
            "description": "The type of schema record.",
            "enum": [
               "main",
               "delta",
               "history_main",
               "history_delta"
            ],
            "name_override": "type",
            "type": "string"
         },
         "secondary_host": {
            "description": "The secondary SAP HANA host in replication.",
            "name_override": "secondary",
            "type": "string"
         },
         "service": {
            "description": "The SAP HANA service.",
            "type": "string"
         },
         "service_memory_used_type": {
            "description": "The type of service memory.",
            "enum": [
               "logical",
               "physical"
            ],
            "name_override": "type",
            "type": "string"
         },
         "service_status": {
            "description": "The status of services.",
            "enum": [
               "active",
               "inactive"
            ],
            "name_override": "status",
            "type": "string"
         },
         "system": {
            "description": "The SAP HANA system.",
            "type": "string"
         },
         "thread_status": {
            "description": "The status of threads.",
            "enum": [
               "active",
               "inactive"
            ],
            "name_override": "status",
            "type": "string"
         },
         "transaction_type": {
            "description": "The transaction type.",
            "enum": [
               "update",
               "commit",
               "rollback"
            ],
            "name_override": "type",
            "type": "string"
         },
         "volume_operation_type": {
            "description": "The type of operation.",
            "enum": [
               "read",
               "write"
            ],
            "name_override": "type",
            "type": "string"
         }
      },
      "metrics": {
         "saphana.alert.count": {
            "attributes": [
               "alert_rating"
            ],
            "description": "Number of current alerts.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{alerts}"
         },
         "saphana.backup.latest": {
            "attributes": [ ],
            "description": "The age of the latest backup by start time.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "s"
         },
         "saphana.column.memory.used": {
            "attributes": [
               "column_memory_type",
               "column_memory_subtype"
            ],
            "description": "The memory used in all columns.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.component.memory.used": {
            "attributes": [
               "component"
            ],
            "description": "The memory used in components.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.connection.count": {
            "attributes": [
               "connection_status"
            ],
            "description": "The number of current connections.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "saphana.cpu.used": {
            "attributes": [
               "cpu_type"
            ],
            "description": "Total CPU time spent.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         },
         "saphana.disk.size.current": {
            "attributes": [
               "path",
               "disk_usage_type",
               "disk_state_used_free"
            ],
            "description": "The disk size.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.host.memory.current": {
            "attributes": [
               "memory_state_used_free"
            ],
            "description": "The amount of physical memory on the host.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.host.swap.current": {
            "attributes": [
               "host_swap_state"
            ],
            "description": "The amount of swap space on the host.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.instance.code_size": {
            "attributes": [ ],
            "description": "The instance code size, including shared libraries of SAP HANA processes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.instance.memory.current": {
            "attributes": [
               "memory_state_used_free"
            ],
            "description": "The size of the memory pool for all SAP HANA processes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.instance.memory.shared.allocated": {
            "attributes": [ ],
            "description": "The shared memory size of SAP HANA processes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.instance.memory.used.peak": {
            "attributes": [ ],
            "description": "The peak memory from the memory pool used by SAP HANA processes since the instance started (this is a sample-based value).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.license.expiration.time": {
            "attributes": [
               "system",
               "product"
            ],
            "description": "The amount of time remaining before license expiration.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "int"
            },
            "unit": "s"
         },
         "saphana.license.limit": {
            "attributes": [
               "system",
               "product"
            ],
            "description": "The allowed product usage as specified by the license (for example, main memory).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{licenses}"
         },
         "saphana.license.peak": {
            "attributes": [
               "system",
               "product"
            ],
            "description": "The peak product usage value during last 13 months, measured periodically.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{licenses}"
         },
         "saphana.network.request.average_time": {
            "attributes": [ ],
            "description": "The average response time calculated over recent requests",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "ms"
         },
         "saphana.network.request.count": {
            "attributes": [
               "active_pending_request_state"
            ],
            "description": "The number of active and pending service requests.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "saphana.network.request.finished.count": {
            "attributes": [
               "internal_external_request_type"
            ],
            "description": "The number of service requests that have completed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "saphana.replication.average_time": {
            "attributes": [
               "primary_host",
               "secondary_host",
               "port",
               "replication_mode"
            ],
            "description": "The average amount of time consumed replicating a log.",
            "enabled": true,
            "gauge": {
               "input_type": "string",
               "value_type": "double"
            },
            "unit": "us"
         },
         "saphana.replication.backlog.size": {
            "attributes": [
               "primary_host",
               "secondary_host",
               "port",
               "replication_mode"
            ],
            "description": "The current replication backlog size.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.replication.backlog.time": {
            "attributes": [
               "primary_host",
               "secondary_host",
               "port",
               "replication_mode"
            ],
            "description": "The current replication backlog.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "us"
         },
         "saphana.row_store.memory.used": {
            "attributes": [
               "row_memory_type"
            ],
            "description": "The used memory for all row tables.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.schema.memory.used.current": {
            "attributes": [
               "schema",
               "schema_memory_type"
            ],
            "description": "The memory size for all tables in schema.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.schema.memory.used.max": {
            "attributes": [
               "schema"
            ],
            "description": "The estimated maximum memory consumption for all fully loaded tables in schema (data for open transactions is not included).",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.schema.operation.count": {
            "attributes": [
               "schema",
               "schema_operation_type"
            ],
            "description": "The number of operations done on all tables in schema.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "saphana.schema.record.compressed.count": {
            "attributes": [
               "schema"
            ],
            "description": "The number of entries in main during the last optimize compression run for all tables in schema.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{records}"
         },
         "saphana.schema.record.count": {
            "attributes": [
               "schema",
               "schema_record_type"
            ],
            "description": "The number of records for all tables in schema.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{records}"
         },
         "saphana.service.code_size": {
            "attributes": [
               "service"
            ],
            "description": "The service code size, including shared libraries.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.count": {
            "attributes": [
               "service_status"
            ],
            "description": "The number of services in a given status.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{services}"
         },
         "saphana.service.memory.compactors.allocated": {
            "attributes": [
               "service"
            ],
            "description": "The part of the memory pool that can potentially (if unpinned) be freed during a memory shortage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.memory.compactors.freeable": {
            "attributes": [
               "service"
            ],
            "description": "The memory that can be freed during a memory shortage.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.memory.effective_limit": {
            "attributes": [
               "service"
            ],
            "description": "The effective maximum memory pool size, calculated considering the pool sizes of other processes.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.memory.heap.current": {
            "attributes": [
               "service",
               "memory_state_used_free"
            ],
            "description": "The size of the heap portion of the memory pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.memory.limit": {
            "attributes": [
               "service"
            ],
            "description": "The configured maximum memory pool size.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.memory.shared.current": {
            "attributes": [
               "service",
               "memory_state_used_free"
            ],
            "description": "The size of the shared portion of the memory pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.memory.used": {
            "attributes": [
               "service",
               "service_memory_used_type"
            ],
            "description": "The used memory from the operating system perspective.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.stack_size": {
            "attributes": [
               "service"
            ],
            "description": "The service stack size.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.service.thread.count": {
            "attributes": [
               "thread_status"
            ],
            "description": "The number of service threads in a given status.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{threads}"
         },
         "saphana.transaction.blocked": {
            "attributes": [ ],
            "description": "The number of transactions waiting for a lock.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{transactions}"
         },
         "saphana.transaction.count": {
            "attributes": [
               "transaction_type"
            ],
            "description": "The number of transactions.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{transactions}"
         },
         "saphana.uptime": {
            "attributes": [
               "system",
               "database"
            ],
            "description": "The uptime of the database.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "s"
         },
         "saphana.volume.operation.count": {
            "attributes": [
               "path",
               "disk_usage_type",
               "volume_operation_type"
            ],
            "description": "The number of operations executed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{operations}"
         },
         "saphana.volume.operation.size": {
            "attributes": [
               "path",
               "disk_usage_type",
               "volume_operation_type"
            ],
            "description": "The size of operations executed.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "By"
         },
         "saphana.volume.operation.time": {
            "attributes": [
               "path",
               "disk_usage_type",
               "volume_operation_type"
            ],
            "description": "The time spent executing operations.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "input_type": "string",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "ms"
         }
      },
      "resource_attributes": {
         "db.system": {
            "description": "The type of database system.",
            "enabled": true,
            "type": "string"
         },
         "saphana.host": {
            "description": "The SAP HANA host.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dehaansa"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "saphana"
   },
   "sapmexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "dmitryax",
               "atoulme"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "aws"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "type": "sapm"
   },
   "sapmreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "sapm"
   },
   "schemaprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "MovieStoreGuy"
            ]
         },
         "distributions": [
            "sumo"
         ],
         "stability": {
            "development": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "schema"
   },
   "sentryexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "AbhiPrasad"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "type": "sentry"
   },
   "servicegraphprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "jpkrohling",
               "mapno"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "deprecated": [
               "traces"
            ]
         },
         "warnings": [ ]
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "servicegraph"
   },
   "signalfxexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "dmitryax",
               "crobert-1"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "aws"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "access_token": "my_fake_token",
            "api_url": "http://localhost:1234",
            "ingest_url": "http://localhost:1234",
            "retry_on_failure": {
               "enabled": false
            },
            "sending_queue": {
               "enabled": false
            }
         },
         "expect_consumer_error": true
      },
      "type": "signalfx"
   },
   "signalfxreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax"
            ],
            "emeritus": null
         },
         "distributions": [
            "contrib",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "signalfx"
   },
   "simpleprometheusreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "fatsheep9146"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "prometheus_simple"
   },
   "skywalkingexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [ ],
            "emeritus": [
               "liqiangz"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "beta": [
               "metrics",
               "logs"
            ]
         }
      },
      "type": "skywalking"
   },
   "skywalkingreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "JaredTan95"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces"
            ],
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": {
            "protocols": {
               "grpc": {
                  "endpoint": "localhost:1234"
               }
            }
         }
      },
      "type": "skywalking"
   },
   "snmpreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "StefanKurek",
               "tamir-michaeli"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": {
            "metrics": {
               "m1": {
                  "gauge": {
                     "value_type": "int"
                  },
                  "scalar_oids": [
                     {
                        "oid": ".1"
                     }
                  ],
                  "unit": "1"
               }
            }
         }
      },
      "type": "snmp"
   },
   "snowflakereceiver": {
      "attributes": {
         "database_name": {
            "description": "Name of database being queried (default is snowflake).",
            "type": "string"
         },
         "error_message": {
            "description": "Error message reported by query if present",
            "type": "string"
         },
         "execution_status": {
            "description": "Execution status of query being reported.",
            "type": "string"
         },
         "is_success": {
            "description": "Login status (success or failure).",
            "type": "string"
         },
         "pipe_name": {
            "description": "Name of snowpipe.",
            "type": "string"
         },
         "query_type": {
            "description": "Type of query performed.",
            "type": "string"
         },
         "reported_client_type": {
            "description": "Client type used for attempt",
            "type": "string"
         },
         "schema_name": {
            "description": "Name of schema associated with query result.",
            "type": "string"
         },
         "service_type": {
            "description": "Service type associateed with metric query",
            "type": "string"
         },
         "user_name": {
            "description": "Username in query being reported.",
            "type": "string"
         },
         "warehouse_name": {
            "description": "Name of warehouse in query being reported on.",
            "type": "string"
         },
         "warehouse_size": {
            "description": "Size of warehouse being reported on.",
            "type": "string"
         }
      },
      "metrics": {
         "snowflake.billing.cloud_service.total": {
            "attributes": [
               "service_type"
            ],
            "description": "Reported total credits used in the cloud service over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.billing.total_credit.total": {
            "attributes": [
               "service_type"
            ],
            "description": "Reported total credits used across account over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.billing.virtual_warehouse.total": {
            "attributes": [
               "service_type"
            ],
            "description": "Reported total credits used by virtual warehouse service over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.billing.warehouse.cloud_service.total": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Credits used across cloud service for given warehouse over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.billing.warehouse.total_credit.total": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Total credits used associated with given warehouse over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.billing.warehouse.virtual_warehouse.total": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Total credits used by virtual warehouse service for given warehouse over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.database.bytes_scanned.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average bytes scanned in a database over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "snowflake.database.query.count": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Total query count for database over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "snowflake.logins.total": {
            "attributes": [
               "error_message",
               "reported_client_type",
               "is_success"
            ],
            "description": "Total login attempts for account over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "snowflake.pipe.credits_used.total": {
            "attributes": [
               "pipe_name"
            ],
            "description": "Snow pipe credits contotaled over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{credits}"
         },
         "snowflake.query.blocked": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Blocked query count for warehouse over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "snowflake.query.bytes_deleted.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average bytes deleted in database over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "snowflake.query.bytes_spilled.local.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Avergae bytes spilled (intermediate results do not fit in memory) by local storage over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "snowflake.query.bytes_spilled.remote.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Avergae bytes spilled (intermediate results do not fit in memory) by remote storage over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "snowflake.query.bytes_written.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average bytes written by database over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By"
         },
         "snowflake.query.compilation_time.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average time taken to compile query over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "snowflake.query.data_scanned_cache.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average percentage of data scanned from cache over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "snowflake.query.executed": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Executed query count for warehouse over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "snowflake.query.execution_time.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average time spent executing queries in database over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "snowflake.query.partitions_scanned.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Number of partitions scanned during query so far over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "snowflake.query.queued_overload": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Overloaded query count for warehouse over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "snowflake.query.queued_provision": {
            "attributes": [
               "warehouse_name"
            ],
            "description": "Number of compute resources queued for provisioning over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": 1
         },
         "snowflake.queued_overload_time.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average time spent in warehouse queue due to warehouse being overloaded over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "snowflake.queued_provisioning_time.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average time spent in warehouse queue waiting for resources to provision over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "snowflake.queued_repair_time.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average time spent in warehouse queue waiting for compute resources to be repaired over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         },
         "snowflake.rows_deleted.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Number of rows deleted from a table (or tables) over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{rows}"
         },
         "snowflake.rows_inserted.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Number of rows inserted into a table (or tables) over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{rows}"
         },
         "snowflake.rows_produced.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average number of rows produced by statement over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{rows}"
         },
         "snowflake.rows_unloaded.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average number of rows unloaded during data export over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{rows}"
         },
         "snowflake.rows_updated.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average number of rows updated in a table over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{rows}"
         },
         "snowflake.session_id.count": {
            "attributes": [
               "user_name"
            ],
            "description": "Distinct session id's associated with snowflake username over the last 24 hour window.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "snowflake.storage.failsafe_bytes.total": {
            "description": "Number of bytes of data in Fail-safe.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "snowflake.storage.stage_bytes.total": {
            "description": "Number of bytes of stage storage used by files in all internal stages (named, table, user).",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "snowflake.storage.storage_bytes.total": {
            "description": "Number of bytes of table storage used, including bytes for data currently in Time Travel.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "snowflake.total_elapsed_time.avg": {
            "attributes": [
               "schema_name",
               "execution_status",
               "error_message",
               "query_type",
               "warehouse_name",
               "database_name",
               "warehouse_size"
            ],
            "description": "Average elapsed time over the last 24 hour window.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "s"
         }
      },
      "resource_attributes": {
         "snowflake.account.name": {
            "description": "Snowflake account being used by receiver.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "shalper2"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "snowflake"
   },
   "solacereceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "mcardy"
            ]
         },
         "distributions": [
            "contrib",
            "sumo",
            "splunk"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "type": "solace"
   },
   "spanmetricsprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "albertteoh"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "splunk",
            "sumo"
         ],
         "stability": {
            "deprecated": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "spanmetrics"
   },
   "spanprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "boostchicken"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "observiq",
            "splunk",
            "sumo",
            "aws",
            "redhat",
            "grafana"
         ],
         "stability": {
            "alpha": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": {
            "name": {
               "from_attributes": [
                  "db.svc",
                  "operation",
                  "id"
               ]
            }
         }
      },
      "type": "span"
   },
   "splunkenterprisereceiver": {
      "attributes": {
         "splunk.bucket.dir": {
            "description": "The bucket super-directory (home, cold, thawed) for each index",
            "type": "string"
         },
         "splunk.index.name": {
            "description": "The name of the index reporting a specific KPI",
            "type": "string"
         },
         "splunk.indexer.status": {
            "description": "The status message reported for a specific object",
            "type": "string"
         },
         "splunk.queue.name": {
            "description": "The name of the queue reporting a specific KPI",
            "type": "string"
         }
      },
      "metrics": {
         "splunk.data.indexes.extended.bucket.count": {
            "attributes": [
               "splunk.index.name"
            ],
            "description": "Count of buckets per index",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{buckets}"
         },
         "splunk.data.indexes.extended.bucket.event.count": {
            "attributes": [
               "splunk.index.name",
               "splunk.bucket.dir"
            ],
            "description": "Count of events in this bucket super-directory",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{events}"
         },
         "splunk.data.indexes.extended.bucket.hot.count": {
            "attributes": [
               "splunk.index.name",
               "splunk.bucket.dir"
            ],
            "description": "(If size > 0) Number of hot buckets",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{buckets}"
         },
         "splunk.data.indexes.extended.bucket.warm.count": {
            "attributes": [
               "splunk.index.name",
               "splunk.bucket.dir"
            ],
            "description": "(If size > 0) Number of warm buckets",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{buckets}"
         },
         "splunk.data.indexes.extended.event.count": {
            "attributes": [
               "splunk.index.name"
            ],
            "description": "Count of events for index, excluding frozen events. Approximately equal to the event_count sum of all buckets.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{events}"
         },
         "splunk.data.indexes.extended.raw.size": {
            "attributes": [
               "splunk.index.name"
            ],
            "description": "Size in bytes on disk of the <bucket>/rawdata/ directories of all buckets in this index, excluding frozen",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "splunk.data.indexes.extended.total.size": {
            "attributes": [
               "splunk.index.name"
            ],
            "description": "Size in bytes on disk of this index",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "splunk.indexer.throughput": {
            "attributes": [
               "splunk.indexer.status"
            ],
            "description": "Gauge tracking average bytes per second throughput of indexer",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By/s"
         },
         "splunk.license.index.usage": {
            "attributes": [
               "splunk.index.name"
            ],
            "description": "Gauge tracking the indexed license usage per index",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         },
         "splunk.server.introspection.queues.current": {
            "attributes": [
               "splunk.queue.name"
            ],
            "description": "Gauge tracking current length of queue",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{queues}"
         },
         "splunk.server.introspection.queues.current.bytes": {
            "attributes": [
               "splunk.queue.name"
            ],
            "description": "Gauge tracking current bytes waiting in queue",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "By"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "shalper2",
               "MovieStoreGuy",
               "greatestusername"
            ]
         },
         "distributions": null,
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "splunkenterprise"
   },
   "splunkhecexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "atoulme",
               "dmitryax"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "endpoint": "http://localhost:0",
            "retry_on_failure": {
               "enabled": false
            },
            "sending_queue": {
               "enabled": false
            },
            "token": "my_fake_token"
         },
         "expect_consumer_error": true
      },
      "type": "splunk_hec"
   },
   "splunkhecreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme"
            ],
            "emeritus": null
         },
         "distributions": [
            "contrib",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "splunk_hec"
   },
   "sqlqueryreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dmitryax",
               "pmcollins"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ],
            "development": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "sqlquery"
   },
   "sqlserverreceiver": {
      "attributes": {
         "page.operations": {
            "description": "The page operation types.",
            "enum": [
               "read",
               "write"
            ],
            "name_override": "type",
            "type": "string"
         }
      },
      "metrics": {
         "sqlserver.batch.request.rate": {
            "description": "Number of batch requests received by SQL Server.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{requests}/s"
         },
         "sqlserver.batch.sql_compilation.rate": {
            "description": "Number of SQL compilations needed.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{compilations}/s"
         },
         "sqlserver.batch.sql_recompilation.rate": {
            "description": "Number of SQL recompilations needed.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{compilations}/s"
         },
         "sqlserver.lock.wait.rate": {
            "description": "Number of lock requests resulting in a wait.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{requests}/s"
         },
         "sqlserver.lock.wait_time.avg": {
            "description": "Average wait time for all lock requests that had to wait.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "ms"
         },
         "sqlserver.page.buffer_cache.hit_ratio": {
            "description": "Pages found in the buffer pool without having to read from disk.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "sqlserver.page.checkpoint.flush.rate": {
            "description": "Number of pages flushed by operations requiring dirty pages to be flushed.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{pages}/s"
         },
         "sqlserver.page.lazy_write.rate": {
            "description": "Number of lazy writes moving dirty pages to disk.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{writes}/s"
         },
         "sqlserver.page.life_expectancy": {
            "description": "Time a page will stay in the buffer pool.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "s"
         },
         "sqlserver.page.operation.rate": {
            "attributes": [
               "page.operations"
            ],
            "description": "Number of physical database page operations issued.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{operations}/s"
         },
         "sqlserver.page.split.rate": {
            "description": "Number of pages split as a result of overflowing index pages.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{pages}/s"
         },
         "sqlserver.transaction.rate": {
            "description": "Number of transactions started for the database (not including XTP-only transactions).",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{transactions}/s"
         },
         "sqlserver.transaction.write.rate": {
            "description": "Number of transactions that wrote to the database and committed.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{transactions}/s"
         },
         "sqlserver.transaction_log.flush.data.rate": {
            "description": "Total number of log bytes flushed.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "By/s"
         },
         "sqlserver.transaction_log.flush.rate": {
            "description": "Number of log flushes.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{flushes}/s"
         },
         "sqlserver.transaction_log.flush.wait.rate": {
            "description": "Number of commits waiting for a transaction log flush.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "{commits}/s"
         },
         "sqlserver.transaction_log.growth.count": {
            "description": "Total number of transaction log expansions for a database.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{growths}"
         },
         "sqlserver.transaction_log.shrink.count": {
            "description": "Total number of transaction log shrinks for a database.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{shrinks}"
         },
         "sqlserver.transaction_log.usage": {
            "description": "Percent of transaction log space used.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "%"
         },
         "sqlserver.user.connection.count": {
            "description": "Number of users connected to the SQL Server.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{connections}"
         }
      },
      "resource_attributes": {
         "sqlserver.computer.name": {
            "description": "The name of the SQL Server instance being monitored.",
            "enabled": false,
            "type": "string"
         },
         "sqlserver.database.name": {
            "description": "The name of the SQL Server database.",
            "enabled": true,
            "type": "string"
         },
         "sqlserver.instance.name": {
            "description": "The name of the SQL Server instance being monitored.",
            "enabled": false,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "StefanKurek"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "sqlserver"
   },
   "sshcheckreceiver": {
      "attributes": {
         "error.message": {
            "description": "Error message recorded during check",
            "type": "string"
         }
      },
      "metrics": {
         "sshcheck.duration": {
            "description": "Measures the duration of SSH connection.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "sshcheck.error": {
            "attributes": [
               "error.message"
            ],
            "description": "Records errors occurring during SSH check.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{error}"
         },
         "sshcheck.sftp_duration": {
            "description": "Measures SFTP request duration.",
            "enabled": false,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "sshcheck.sftp_error": {
            "attributes": [
               "error.message"
            ],
            "description": "Records errors occurring during SFTP check.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{error}"
         },
         "sshcheck.sftp_status": {
            "description": "1 if the SFTP server replied to request, otherwise 0.",
            "enabled": false,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         },
         "sshcheck.status": {
            "description": "1 if the SSH client successfully connected, otherwise 0.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": 1
         }
      },
      "resource_attributes": {
         "ssh.endpoint": {
            "description": "Full SSH endpoint",
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "nslaughter",
               "codeboten"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "sshcheck"
   },
   "statsdreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "jmacd",
               "dmitryax"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "sumo",
            "aws"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "statsd"
   },
   "sumologicexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "sumo-drosiek"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "beta": [
               "metrics",
               "logs"
            ]
         }
      },
      "type": "sumologic"
   },
   "sumologicprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "aboguszewski-sumo",
               "astencel-sumo",
               "sumo-drosiek"
            ]
         },
         "distributions": [
            "contrib",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces",
               "metrics",
               "logs"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "sumologic"
   },
   "syslogexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "kkujawa-sumo",
               "rnishtala-sumo",
               "astencel-sumo"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "type": "syslog"
   },
   "syslogreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "protocol": "rfc5424",
            "tcp": {
               "listen_address": "localhost:0"
            }
         }
      },
      "type": "syslog"
   },
   "system": {
      "parent": "resourcedetection",
      "resource_attributes": {
         "host.arch": {
            "description": "The host.arch",
            "enabled": false,
            "type": "string"
         },
         "host.cpu.cache.l2.size": {
            "description": "The host.cpu.cache.l2.size",
            "enabled": false,
            "type": "int"
         },
         "host.cpu.family": {
            "description": "The host.cpu.family",
            "enabled": false,
            "type": "string"
         },
         "host.cpu.model.id": {
            "description": "The host.cpu.model.id",
            "enabled": false,
            "type": "string"
         },
         "host.cpu.model.name": {
            "description": "The host.cpu.model.name",
            "enabled": false,
            "type": "string"
         },
         "host.cpu.stepping": {
            "description": "The host.cpu.stepping",
            "enabled": false,
            "type": "int"
         },
         "host.cpu.vendor.id": {
            "description": "The host.cpu.vendor.id",
            "enabled": false,
            "type": "string"
         },
         "host.id": {
            "description": "The host.id",
            "enabled": false,
            "type": "string"
         },
         "host.ip": {
            "description": "IP addresses for the host",
            "enabled": false,
            "type": "slice"
         },
         "host.mac": {
            "description": "MAC addresses for the host",
            "enabled": false,
            "type": "slice"
         },
         "host.name": {
            "description": "The host.name",
            "enabled": true,
            "type": "string"
         },
         "os.description": {
            "description": "Human readable OS version information.",
            "enabled": false,
            "type": "string"
         },
         "os.type": {
            "description": "The os.type",
            "enabled": true,
            "type": "string"
         }
      },
      "type": "resourcedetectionprocessor/system"
   },
   "tailsamplingprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "jpkrohling"
            ]
         },
         "distributions": [
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "splunk",
            "sumo"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "tail_sampling"
   },
   "tcplogreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "listen_address": "localhost:0"
         }
      },
      "type": "tcplog"
   },
   "tencentcloudlogserviceexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "wgliang",
               "yiyang5055"
            ]
         },
         "distributions": [
            "contrib"
         ],
         "stability": {
            "beta": [
               "logs"
            ]
         }
      },
      "type": "tencentcloud_logservice"
   },
   "transformprocessor": {
      "status": {
         "class": "processor",
         "codeowners": {
            "active": [
               "TylerHelmuth",
               "kentquirk",
               "bogdandrutu",
               "evan-bradley"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo",
            "grafana",
            "liatrio"
         ],
         "stability": {
            "alpha": [
               "traces",
               "metrics",
               "logs"
            ]
         },
         "warnings": [
            "Unsound Transformations",
            "Identity Conflict",
            "Orphaned Telemetry",
            "Other"
         ]
      },
      "tests": {
         "config": null
      },
      "type": "transform"
   },
   "udplogreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo",
            "splunk"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "listen_address": "localhost:0"
         }
      },
      "type": "udplog"
   },
   "vcenterreceiver": {
      "attributes": {
         "disk_direction": {
            "description": "The direction of disk latency.",
            "enum": [
               "read",
               "write"
            ],
            "name_override": "direction",
            "type": "string"
         },
         "disk_state": {
            "description": "The state of storage and whether it is already allocated or free.",
            "enum": [
               "available",
               "used"
            ],
            "type": "string"
         },
         "disk_type": {
            "description": "The type of storage device that is being recorded.",
            "enum": [
               "virtual",
               "physical"
            ],
            "type": "string"
         },
         "host_effective": {
            "description": "Whether the host is effective in the vCenter cluster.",
            "name_override": "effective",
            "type": "bool"
         },
         "object_name": {
            "description": "The object on the virtual machine or host that is being reported on.",
            "name_override": "object",
            "type": "string"
         },
         "throughput_direction": {
            "description": "The direction of network throughput.",
            "enum": [
               "transmitted",
               "received"
            ],
            "name_override": "direction",
            "type": "string"
         },
         "vm_count_power_state": {
            "description": "Whether the virtual machines are powered on or off.",
            "enum": [
               "on",
               "off"
            ],
            "name_override": "power_state",
            "type": "string"
         }
      },
      "metrics": {
         "vcenter.cluster.cpu.effective": {
            "attributes": [ ],
            "description": "The effective CPU available to the cluster. This value excludes CPU from hosts in maintenance mode or are unresponsive.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{MHz}"
         },
         "vcenter.cluster.cpu.limit": {
            "attributes": [ ],
            "description": "The amount of CPU available to the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{MHz}"
         },
         "vcenter.cluster.host.count": {
            "attributes": [
               "host_effective"
            ],
            "description": "The number of hosts in the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{hosts}"
         },
         "vcenter.cluster.memory.effective": {
            "attributes": [ ],
            "description": "The effective memory of the cluster. This value excludes memory from hosts in maintenance mode or are unresponsive.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "vcenter.cluster.memory.limit": {
            "attributes": [ ],
            "description": "The available memory of the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "vcenter.cluster.memory.used": {
            "attributes": [ ],
            "description": "The memory that is currently used by the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "vcenter.cluster.vm.count": {
            "attributes": [
               "vm_count_power_state"
            ],
            "description": "the number of virtual machines in the cluster.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{virtual_machines}"
         },
         "vcenter.datastore.disk.usage": {
            "attributes": [
               "disk_state"
            ],
            "description": "The amount of space in the datastore.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "vcenter.datastore.disk.utilization": {
            "attributes": [ ],
            "description": "The utilization of the datastore.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "vcenter.host.cpu.usage": {
            "attributes": [ ],
            "description": "The amount of CPU used by the host.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MHz"
         },
         "vcenter.host.cpu.utilization": {
            "attributes": [ ],
            "description": "The CPU utilization of the host system.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "vcenter.host.disk.latency.avg": {
            "attributes": [
               "disk_direction",
               "object_name"
            ],
            "description": "The latency of operations to the host system's disk.",
            "enabled": true,
            "extended_documentation": "This latency is the sum of the device and kernel read and write latencies. Requires Performance Counter level 2 for metric to populate.",
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "vcenter.host.disk.latency.max": {
            "attributes": [
               "object_name"
            ],
            "description": "Highest latency value across all disks used by the host.",
            "enabled": true,
            "extended_documentation": "As measured over the most recent 20s interval. Requires Performance Level 3.",
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "vcenter.host.disk.throughput": {
            "attributes": [
               "disk_direction",
               "object_name"
            ],
            "description": "Average number of kilobytes read from or written to the disk each second.",
            "enabled": true,
            "extended_documentation": "As measured over the most recent 20s interval. Aggregated disk I/O rate. Requires Performance Level 4.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{KiBy/s}"
         },
         "vcenter.host.memory.usage": {
            "attributes": [ ],
            "description": "The amount of memory the host system is using.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MiBy"
         },
         "vcenter.host.memory.utilization": {
            "attributes": [ ],
            "description": "The percentage of the host system's memory capacity that is being utilized.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "vcenter.host.network.packet.count": {
            "attributes": [
               "throughput_direction",
               "object_name"
            ],
            "description": "The number of packets transmitted and received, as measured over the most recent 20s interval.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{packets/sec}"
         },
         "vcenter.host.network.packet.errors": {
            "attributes": [
               "throughput_direction",
               "object_name"
            ],
            "description": "The summation of packet errors on the host network.",
            "enabled": true,
            "extended_documentation": "As measured over the most recent 20s interval.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{errors}"
         },
         "vcenter.host.network.throughput": {
            "attributes": [
               "throughput_direction",
               "object_name"
            ],
            "description": "The amount of data that was transmitted or received over the network by the host.",
            "enabled": true,
            "extended_documentation": "As measured over the most recent 20s interval.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{KiBy/s}"
         },
         "vcenter.host.network.usage": {
            "attributes": [
               "object_name"
            ],
            "description": "The sum of the data transmitted and received for all the NIC instances of the host.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{KiBy/s}"
         },
         "vcenter.resource_pool.cpu.shares": {
            "attributes": [ ],
            "description": "The amount of shares of CPU in the resource pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{shares}"
         },
         "vcenter.resource_pool.cpu.usage": {
            "attributes": [ ],
            "description": "The usage of the CPU used by the resource pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{MHz}"
         },
         "vcenter.resource_pool.memory.shares": {
            "attributes": [ ],
            "description": "The amount of shares of memory in the resource pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{shares}"
         },
         "vcenter.resource_pool.memory.usage": {
            "attributes": [ ],
            "description": "The usage of the memory by the resource pool.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MiBy"
         },
         "vcenter.vm.cpu.usage": {
            "attributes": [ ],
            "description": "The amount of CPU used by the VM.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MHz"
         },
         "vcenter.vm.cpu.utilization": {
            "attributes": [ ],
            "description": "The CPU utilization of the VM.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "vcenter.vm.disk.latency.avg": {
            "attributes": [
               "disk_direction",
               "disk_type",
               "object_name"
            ],
            "description": "The latency of operations to the virtual machine's disk.",
            "enabled": true,
            "extended_documentation": "Requires Performance Counter level 2 for metric to populate. As measured over the most recent 20s interval.",
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "vcenter.vm.disk.latency.max": {
            "attributes": [
               "object_name"
            ],
            "description": "The highest reported total latency (device and kernel times) over an interval of 20 seconds.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "vcenter.vm.disk.throughput": {
            "attributes": [
               "object_name"
            ],
            "description": "The throughput of the virtual machine's disk.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By/sec"
         },
         "vcenter.vm.disk.usage": {
            "attributes": [
               "disk_state"
            ],
            "description": "The amount of storage space used by the virtual machine.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "vcenter.vm.disk.utilization": {
            "attributes": [ ],
            "description": "The utilization of storage on the virtual machine.",
            "enabled": true,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "vcenter.vm.memory.ballooned": {
            "attributes": [ ],
            "description": "The amount of memory that is ballooned due to virtualization.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MiBy"
         },
         "vcenter.vm.memory.swapped": {
            "attributes": [ ],
            "description": "The portion of memory that is granted to this VM from the host's swap space.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MiBy"
         },
         "vcenter.vm.memory.swapped_ssd": {
            "attributes": [ ],
            "description": "The amount of memory swapped to fast disk device such as SSD.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "KiBy"
         },
         "vcenter.vm.memory.usage": {
            "attributes": [ ],
            "description": "The amount of memory that is used by the virtual machine.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "MiBy"
         },
         "vcenter.vm.memory.utilization": {
            "attributes": [ ],
            "description": "The memory utilization of the VM.",
            "enabled": false,
            "gauge": {
               "value_type": "double"
            },
            "unit": "%"
         },
         "vcenter.vm.network.packet.count": {
            "attributes": [
               "throughput_direction",
               "object_name"
            ],
            "description": "The amount of packets that was received or transmitted over the instance's network.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{packets/sec}"
         },
         "vcenter.vm.network.throughput": {
            "attributes": [
               "throughput_direction",
               "object_name"
            ],
            "description": "The amount of data that was transmitted or received over the network of the virtual machine.",
            "enabled": true,
            "extended_documentation": "As measured over the most recent 20s interval.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By/sec"
         },
         "vcenter.vm.network.usage": {
            "attributes": [
               "object_name"
            ],
            "description": "The network utilization combined transmit and receive rates during an interval.",
            "enabled": true,
            "extended_documentation": "As measured over the most recent 20s interval.",
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{KiBy/s}"
         }
      },
      "resource_attributes": {
         "vcenter.cluster.name": {
            "description": "The name of the vCenter Cluster.",
            "enabled": true,
            "type": "string"
         },
         "vcenter.datastore.name": {
            "description": "The name of the vCenter datastore.",
            "enabled": true,
            "type": "string"
         },
         "vcenter.host.name": {
            "description": "The hostname of the vCenter ESXi host.",
            "enabled": true,
            "type": "string"
         },
         "vcenter.resource_pool.inventory_path": {
            "description": "The inventory path of the resource pool.",
            "enabled": true,
            "type": "string"
         },
         "vcenter.resource_pool.name": {
            "description": "The name of the resource pool.",
            "enabled": true,
            "type": "string"
         },
         "vcenter.vm.id": {
            "description": "The instance UUID of the virtual machine.",
            "enabled": true,
            "type": "string"
         },
         "vcenter.vm.name": {
            "description": "The name of the virtual machine.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "schmikei"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "vcenter"
   },
   "wavefrontreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "samiura"
            ]
         },
         "distributions": [
            "contrib",
            "sumo",
            "splunk"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null,
         "skip_lifecycle": true
      },
      "type": "wavefront"
   },
   "webhookeventreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "atoulme",
               "shalper2"
            ],
            "emeritus": null
         },
         "distributions": null,
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "tests": {
         "config": {
            "endpoint": "127.0.0.1:8088"
         }
      },
      "type": "webhookevent"
   },
   "windowseventlogreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski",
               "armstrmi",
               "pjanotti"
            ]
         },
         "distributions": [
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "alpha": [
               "logs"
            ]
         }
      },
      "type": "windowseventlog"
   },
   "windowsperfcountersreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "dashpole"
            ]
         },
         "distributions": [
            "contrib",
            "splunk",
            "observiq",
            "sumo"
         ],
         "stability": {
            "beta": [
               "metrics"
            ]
         }
      },
      "type": "windowsperfcounters"
   },
   "zipkinexporter": {
      "status": {
         "class": "exporter",
         "codeowners": {
            "active": [
               "MovieStoreGuy",
               "astencel-sumo",
               "crobert-1"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "observiq",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "type": "zipkin"
   },
   "zipkinreceiver": {
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "MovieStoreGuy",
               "astencel-sumo",
               "crobert-1"
            ]
         },
         "distributions": [
            "core",
            "contrib",
            "aws",
            "grafana",
            "observiq",
            "redhat",
            "splunk",
            "sumo",
            "liatrio"
         ],
         "stability": {
            "beta": [
               "traces"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "zipkin"
   },
   "zookeeperreceiver": {
      "attributes": {
         "direction": {
            "description": "State of a packet based on io direction.",
            "enum": [
               "received",
               "sent"
            ],
            "type": "string"
         },
         "state": {
            "description": "State of followers",
            "enum": [
               "synced",
               "unsynced"
            ],
            "type": "string"
         }
      },
      "metrics": {
         "zookeeper.connection.active": {
            "description": "Number of active clients connected to a ZooKeeper server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{connections}"
         },
         "zookeeper.data_tree.ephemeral_node.count": {
            "description": "Number of ephemeral nodes that a ZooKeeper server has in its data tree.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{nodes}"
         },
         "zookeeper.data_tree.size": {
            "description": "Size of data in bytes that a ZooKeeper server has in its data tree.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "By"
         },
         "zookeeper.file_descriptor.limit": {
            "description": "Maximum number of file descriptors that a ZooKeeper server can open.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "{file_descriptors}"
         },
         "zookeeper.file_descriptor.open": {
            "description": "Number of file descriptors that a ZooKeeper server has open.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{file_descriptors}"
         },
         "zookeeper.follower.count": {
            "attributes": [
               "state"
            ],
            "description": "The number of followers. Only exposed by the leader.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{followers}"
         },
         "zookeeper.fsync.exceeded_threshold.count": {
            "description": "Number of times fsync duration has exceeded warning threshold.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{events}"
         },
         "zookeeper.latency.avg": {
            "description": "Average time in milliseconds for requests to be processed.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "zookeeper.latency.max": {
            "description": "Maximum time in milliseconds for requests to be processed.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "zookeeper.latency.min": {
            "description": "Minimum time in milliseconds for requests to be processed.",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": "ms"
         },
         "zookeeper.packet.count": {
            "attributes": [
               "direction"
            ],
            "description": "The number of ZooKeeper packets received or sent by a server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": true,
               "value_type": "int"
            },
            "unit": "{packets}"
         },
         "zookeeper.request.active": {
            "description": "Number of currently executing requests.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{requests}"
         },
         "zookeeper.ruok": {
            "description": "Response from zookeeper ruok command",
            "enabled": true,
            "gauge": {
               "value_type": "int"
            },
            "unit": 1
         },
         "zookeeper.sync.pending": {
            "description": "The number of pending syncs from the followers. Only exposed by the leader.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{syncs}"
         },
         "zookeeper.watch.count": {
            "description": "Number of watches placed on Z-Nodes on a ZooKeeper server.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{watches}"
         },
         "zookeeper.znode.count": {
            "description": "Number of z-nodes that a ZooKeeper server has in its data tree.",
            "enabled": true,
            "sum": {
               "aggregation_temporality": "cumulative",
               "monotonic": false,
               "value_type": "int"
            },
            "unit": "{znodes}"
         }
      },
      "resource_attributes": {
         "server.state": {
            "description": "State of the Zookeeper server (leader, standalone or follower).",
            "enabled": true,
            "type": "string"
         },
         "zk.version": {
            "description": "Zookeeper version of the instance.",
            "enabled": true,
            "type": "string"
         }
      },
      "status": {
         "class": "receiver",
         "codeowners": {
            "active": [
               "djaglowski"
            ]
         },
         "distributions": [
            "contrib",
            "observiq",
            "sumo"
         ],
         "stability": {
            "development": [
               "metrics"
            ]
         }
      },
      "tests": {
         "config": null
      },
      "type": "zookeeper"
   }
}
