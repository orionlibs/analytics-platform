import fs from 'fs'
import { InfoObject } from 'openapi3-ts/oas30'
import orval from 'orval'
import path from 'path'
import { DEFAULT_SCHEMA_TITLE } from '../constants'
import { NoFilesGeneratedError } from '../errors'
import {
  formatFileWithPrettier,
  getPackageDetails,
  hasOnlyComments,
  OutputOverrider,
} from '../helper'
import { logger } from '../logger'
import { GenerateK6SDKOptions } from '../type'
import { getK6ClientBuilder } from './k6Client'

const outputOverrider = OutputOverrider.getInstance()
const packageDetails = getPackageDetails()

const generatedFileHeaderGenerator = (info: InfoObject) => {
  return [
    `Automatically generated by ${packageDetails.name}: ${packageDetails.version}`,
    `Do not edit manually.`,
    ...(info.title ? [info.title] : []),
    ...(info.description ? [info.description] : []),
    ...(info.version ? [`Service version: ${info.version}`] : []),
  ]
}

const afterAllFilesWriteHandler = async (
  filePaths: string[],
  outputOverrider: OutputOverrider
) => {
  const removeSingleFile = (filePath: string) => {
    try {
      fs.unlinkSync(filePath)
    } catch (error) {
      // This is non-critical, so we just log it
      logger.debug(
        `afterAllFilesWriteHandler ~ Error deleting file ${filePath}: ${error}`
      )
    }
  }
  const emptyFileList: string[] = []

  for (const filePath of filePaths) {
    // There is a bug in the orval library which generates empty files when tags filter is applied
    // and no matching endpoints are found and used mode is split or single.
    // It generates the file with only the header comment.
    // Hence, we manually remove those empty files.
    // Issue link - https://github.com/orval-labs/orval/issues/1691

    if (hasOnlyComments(fs.readFileSync(filePath, 'utf-8'))) {
      emptyFileList.push(filePath)
      // Delete the file
      removeSingleFile(filePath)
      continue
    }
    try {
      await formatFileWithPrettier(filePath)
    } catch (error) {
      await outputOverrider.temporarilyWriteToStdoutAndStderr(async () => {
        logger.error(`Error in formatting file ${filePath}: ${error}`)
      })
    }

    const fileName = path.basename(filePath)

    if (fileName === '.ts') {
      // Generated SDK had no name because there was no title in the schema
      // Rename it to the default name
      const directoryPath = path.dirname(filePath)
      const newPath = path.join(directoryPath, `${DEFAULT_SCHEMA_TITLE}.ts`)
      logger.debug(
        `afterAllFilesWriteHandler ~ Renaming ${filePath} to ${newPath}`
      )
      fs.renameSync(filePath, newPath)
    }
  }

  if (emptyFileList.length > 0) {
    logger.debug(
      `afterAllFilesWriteHandler ~ The following files were empty and removed: ${emptyFileList.join(
        ', '
      )}`
    )
  }

  // Return the list of generated file paths excluding the empty files
  const filteredFilePaths = filePaths.filter(
    (filePath) => !emptyFileList.includes(filePath)
  )

  // Check if all the filtered file path end with `.schemas.ts`
  if (filteredFilePaths.every((filePath) => filePath.endsWith('.schemas.ts'))) {
    // If yes we should remove them as only schemas files is not needed
    filteredFilePaths.map(removeSingleFile)
    return []
  }

  return filteredFilePaths
}

export default async ({
  openApiPath,
  outputDir,
  shouldGenerateSampleK6Script,
  analyticsData,
  mode,
  tags,
}: GenerateK6SDKOptions) => {
  /**
   * Note!
   * 1. override.requestOptions is not supported for the custom K6 client
   * 2. override.mutator is not supported for the custom K6 client
   */
  const generatedFilePaths: string[] = []
  await outputOverrider.redirectOutputToNullStream(async () => {
    await orval({
      input: {
        target: openApiPath,
        filters: { tags: tags && tags.length > 0 ? tags : undefined },
      },
      output: {
        target: outputDir,
        mode: mode,
        client: () =>
          getK6ClientBuilder(shouldGenerateSampleK6Script, analyticsData),
        override: {
          header: generatedFileHeaderGenerator,
        },
        headers: true,
      },
      hooks: {
        afterAllFilesWrite: async (filePaths: string[]) => {
          const filteredFilePaths = await afterAllFilesWriteHandler(
            filePaths,
            outputOverrider
          )
          generatedFilePaths.push(...filteredFilePaths)
        },
      },
    })
  })

  if (generatedFilePaths.length === 0) {
    const tagsMessage =
      tags?.length && tags.length > 0
        ? ` Applied tag filter(s): ${tags.join(', ')}. `
        : ' '
    throw new NoFilesGeneratedError(
      `No files were generated.${tagsMessage}Try running with --verbose flag to get more details.`
    )
  }
}
